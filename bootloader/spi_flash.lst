   1               		.file	"spi_flash.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.SPI_transfer,"ax",@progbits
  11               	.global	SPI_transfer
  13               	SPI_transfer:
  14               	.LFB4:
  15               		.file 1 "spi_flash.c"
   1:spi_flash.c   **** #include "spi_flash.h"
   2:spi_flash.c   **** 
   3:spi_flash.c   **** // internal prototypes
   4:spi_flash.c   **** uint8_t SPI_transfer(uint8_t data);
   5:spi_flash.c   **** uint8_t FLASH_busy(void);
   6:spi_flash.c   **** uint16_t readDeviceId(void);
   7:spi_flash.c   **** /* -============================== SPI DRIVER ==========================- */
   8:spi_flash.c   **** bool SPI_init(void){
   9:spi_flash.c   ****    
  10:spi_flash.c   ****     SPI_DDR |= _BV(SPI_SS_PIN) | _BV(SPI_MOSI_PIN) | _BV(SPI_CLK_PIN); // OUTPUTS for SS, MOSI, SCK
  11:spi_flash.c   ****     FLASHSS_DDR |= _BV(SPI_SS_PIN);
  12:spi_flash.c   ****     SPI_PORT |= _BV(SPI_SS_PIN); //PB2 output: High (deselect other SPI chips) 
  13:spi_flash.c   **** 
  14:spi_flash.c   ****     /* Warning: if the SS pin ever becomes a LOW INPUT then SPI automatically switches to Slave,
  15:spi_flash.c   ****      * so the data direction of the SS pin MUST be kept as OUTPUT. */
  16:spi_flash.c   ****     SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); //enable SPI and set SPI to MASTER mode
  17:spi_flash.c   ****    
  18:spi_flash.c   ****     /*read first 2 bytes of JEDECID, if chip is present it should return a non-0 and non-FF value *
  19:spi_flash.c   ****     uint16_t deviceId = readDeviceId();
  20:spi_flash.c   ****     if (deviceId==0 || deviceId==0xFF) return false;
  21:spi_flash.c   **** 
  22:spi_flash.c   ****     return true;
  23:spi_flash.c   **** }
  24:spi_flash.c   **** 
  25:spi_flash.c   **** uint8_t SPI_transfer(uint8_t data) {
  16               		.loc 1 25 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  26:spi_flash.c   ****     SPDR = data;
  23               		.loc 1 26 0
  24 0000 8EBD      		out 0x2e,r24
  27:spi_flash.c   ****     /*
  28:spi_flash.c   ****      * The following NOP introduces a small delay that can prevent the wait
  29:spi_flash.c   ****      * loop form iterating when running at the maximum speed. This gives
  30:spi_flash.c   ****      * about 10% more speed, even if it seems counter-intuitive. At lower
  31:spi_flash.c   ****      * speeds it is unnoticed.
  32:spi_flash.c   ****      */
  33:spi_flash.c   ****      __asm__ __volatile__("nop");
  25               		.loc 1 33 0
  26               	/* #APP */
  27               	 ;  33 "spi_flash.c" 1
  28 0002 0000      		nop
  29               	 ;  0 "" 2
  30               	/* #NOAPP */
  31               	.L2:
  34:spi_flash.c   ****     while (!(SPSR & _BV(SPIF))) ; // wait
  32               		.loc 1 34 0 discriminator 1
  33 0004 0DB4      		in __tmp_reg__,0x2d
  34 0006 07FE      		sbrs __tmp_reg__,7
  35 0008 00C0      		rjmp .L2
  35:spi_flash.c   ****     return SPDR;
  36               		.loc 1 35 0
  37 000a 8EB5      		in r24,0x2e
  38               	.LVL1:
  39               	/* epilogue start */
  36:spi_flash.c   ****   }
  40               		.loc 1 36 0
  41 000c 0895      		ret
  42               		.cfi_endproc
  43               	.LFE4:
  45               		.section	.text.FLASH_busy,"ax",@progbits
  46               	.global	FLASH_busy
  48               	FLASH_busy:
  49               	.LFB5:
  37:spi_flash.c   **** 
  38:spi_flash.c   **** 
  39:spi_flash.c   **** uint8_t FLASH_busy(void) {
  50               		.loc 1 39 0
  51               		.cfi_startproc
  52               	/* prologue: function */
  53               	/* frame size = 0 */
  54               	/* stack size = 0 */
  55               	.L__stack_usage = 0
  40:spi_flash.c   **** 
  41:spi_flash.c   ****   FLASH_SELECT;
  56               		.loc 1 41 0
  57 0000 4798      		cbi 0x8,7
  42:spi_flash.c   ****   SPI_transfer(SPIFLASH_STATUSREAD);
  58               		.loc 1 42 0
  59 0002 85E0      		ldi r24,lo8(5)
  60 0004 0E94 0000 		call SPI_transfer
  61               	.LVL2:
  43:spi_flash.c   ****   uint8_t status = SPI_transfer(0);
  62               		.loc 1 43 0
  63 0008 80E0      		ldi r24,0
  64 000a 0E94 0000 		call SPI_transfer
  65               	.LVL3:
  44:spi_flash.c   ****   FLASH_UNSELECT;
  66               		.loc 1 44 0
  67 000e 479A      		sbi 0x8,7
  45:spi_flash.c   **** 
  46:spi_flash.c   ****   return status & 1;
  47:spi_flash.c   **** }
  68               		.loc 1 47 0
  69 0010 8170      		andi r24,lo8(1)
  70               	.LVL4:
  71               	/* epilogue start */
  72 0012 0895      		ret
  73               		.cfi_endproc
  74               	.LFE5:
  76               		.section	.text.readDeviceId,"ax",@progbits
  77               	.global	readDeviceId
  79               	readDeviceId:
  80               	.LFB6:
  48:spi_flash.c   **** 
  49:spi_flash.c   **** /* Return device unique ID. Used to verify the connection with the FLASH during initiliaziation */
  50:spi_flash.c   **** uint16_t readDeviceId(void)
  51:spi_flash.c   **** {
  81               		.loc 1 51 0
  82               		.cfi_startproc
  83 0000 CF93      		push r28
  84               	.LCFI0:
  85               		.cfi_def_cfa_offset 3
  86               		.cfi_offset 28, -2
  87 0002 DF93      		push r29
  88               	.LCFI1:
  89               		.cfi_def_cfa_offset 4
  90               		.cfi_offset 29, -3
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 2 */
  94               	.L__stack_usage = 2
  52:spi_flash.c   ****   FLASH_SELECT
  95               		.loc 1 52 0
  96 0004 4798      		cbi 0x8,7
  53:spi_flash.c   ****   SPI_transfer(SPIFLASH_JEDECID);
  97               		.loc 1 53 0
  98 0006 8FE9      		ldi r24,lo8(-97)
  99 0008 0E94 0000 		call SPI_transfer
 100               	.LVL5:
  54:spi_flash.c   ****   uint16_t jedecid = SPI_transfer(0) << 8;
 101               		.loc 1 54 0
 102 000c 80E0      		ldi r24,0
 103 000e 0E94 0000 		call SPI_transfer
 104               	.LVL6:
 105 0012 C82F      		mov r28,r24
 106 0014 D0E0      		ldi r29,0
 107 0016 DC2F      		mov r29,r28
 108 0018 CC27      		clr r28
 109               	.LVL7:
  55:spi_flash.c   ****   jedecid |= SPI_transfer(0);
 110               		.loc 1 55 0
 111 001a 80E0      		ldi r24,0
 112 001c 0E94 0000 		call SPI_transfer
 113               	.LVL8:
  56:spi_flash.c   ****   FLASH_UNSELECT
 114               		.loc 1 56 0
 115 0020 479A      		sbi 0x8,7
  57:spi_flash.c   ****   return jedecid;
  58:spi_flash.c   **** }
 116               		.loc 1 58 0
 117 0022 9E01      		movw r18,r28
 118 0024 282B      		or r18,r24
 119 0026 C901      		movw r24,r18
 120               	.LVL9:
 121               	/* epilogue start */
 122 0028 DF91      		pop r29
 123 002a CF91      		pop r28
 124 002c 0895      		ret
 125               		.cfi_endproc
 126               	.LFE6:
 128               		.section	.text.SPI_init,"ax",@progbits
 129               	.global	SPI_init
 131               	SPI_init:
 132               	.LFB3:
   8:spi_flash.c   ****    
 133               		.loc 1 8 0
 134               		.cfi_startproc
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  10:spi_flash.c   ****     FLASHSS_DDR |= _BV(SPI_SS_PIN);
 139               		.loc 1 10 0
 140 0000 84B1      		in r24,0x4
 141 0002 8760      		ori r24,lo8(7)
 142 0004 84B9      		out 0x4,r24
  11:spi_flash.c   ****     SPI_PORT |= _BV(SPI_SS_PIN); //PB2 output: High (deselect other SPI chips) 
 143               		.loc 1 11 0
 144 0006 409A      		sbi 0x8,0
  12:spi_flash.c   **** 
 145               		.loc 1 12 0
 146 0008 289A      		sbi 0x5,0
  16:spi_flash.c   ****    
 147               		.loc 1 16 0
 148 000a 81E5      		ldi r24,lo8(81)
 149 000c 8CBD      		out 0x2c,r24
  19:spi_flash.c   ****     if (deviceId==0 || deviceId==0xFF) return false;
 150               		.loc 1 19 0
 151 000e 0E94 0000 		call readDeviceId
 152               	.LVL10:
 153 0012 9C01      		movw r18,r24
 154               	.LVL11:
  20:spi_flash.c   **** 
 155               		.loc 1 20 0
 156 0014 892B      		or r24,r25
 157 0016 01F0      		breq .L9
  20:spi_flash.c   **** 
 158               		.loc 1 20 0 is_stmt 0 discriminator 2
 159 0018 81E0      		ldi r24,lo8(1)
 160 001a 2F3F      		cpi r18,-1
 161 001c 3105      		cpc r19,__zero_reg__
 162 001e 01F4      		brne .L6
 163               	.L9:
  20:spi_flash.c   **** 
 164               		.loc 1 20 0
 165 0020 80E0      		ldi r24,0
 166               	.L6:
 167               	/* epilogue start */
  23:spi_flash.c   **** 
 168               		.loc 1 23 0 is_stmt 1
 169 0022 0895      		ret
 170               		.cfi_endproc
 171               	.LFE3:
 173               		.section	.text.Flash_readByteArray,"ax",@progbits
 174               	.global	Flash_readByteArray
 176               	Flash_readByteArray:
 177               	.LFB7:
  59:spi_flash.c   **** 
  60:spi_flash.c   **** /* Read array of bytes 
  61:spi_flash.c   ****  *  1. *buf - array where the data will be stored
  62:spi_flash.c   ****  *  2. addr - starting address 
  63:spi_flash.c   ****  *  3. len - number of bytes to read 
  64:spi_flash.c   ****  */
  65:spi_flash.c   **** void Flash_readByteArray(void *buf, uint32_t addr, uint8_t len){
 178               		.loc 1 65 0
 179               		.cfi_startproc
 180               	.LVL12:
 181 0000 EF92      		push r14
 182               	.LCFI2:
 183               		.cfi_def_cfa_offset 3
 184               		.cfi_offset 14, -2
 185 0002 FF92      		push r15
 186               	.LCFI3:
 187               		.cfi_def_cfa_offset 4
 188               		.cfi_offset 15, -3
 189 0004 0F93      		push r16
 190               	.LCFI4:
 191               		.cfi_def_cfa_offset 5
 192               		.cfi_offset 16, -4
 193 0006 1F93      		push r17
 194               	.LCFI5:
 195               		.cfi_def_cfa_offset 6
 196               		.cfi_offset 17, -5
 197 0008 CF93      		push r28
 198               	.LCFI6:
 199               		.cfi_def_cfa_offset 7
 200               		.cfi_offset 28, -6
 201 000a DF93      		push r29
 202               	.LCFI7:
 203               		.cfi_def_cfa_offset 8
 204               		.cfi_offset 29, -7
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 6 */
 208               	.L__stack_usage = 6
 209 000c F82E      		mov r15,r24
 210 000e 192F      		mov r17,r25
 211 0010 EA01      		movw r28,r20
 212 0012 E62E      		mov r14,r22
 213 0014 022F      		mov r16,r18
 214               	.LVL13:
 215               	.L11:
  66:spi_flash.c   **** 
  67:spi_flash.c   ****     while(FLASH_busy());
 216               		.loc 1 67 0 discriminator 1
 217 0016 0E94 0000 		call FLASH_busy
 218               	.LVL14:
 219 001a 8111      		cpse r24,__zero_reg__
 220 001c 00C0      		rjmp .L11
  68:spi_flash.c   ****     FLASH_SELECT
 221               		.loc 1 68 0
 222 001e 4798      		cbi 0x8,7
  69:spi_flash.c   ****     SPI_transfer(SPIFLASH_ARRAYREAD);
 223               		.loc 1 69 0
 224 0020 8BE0      		ldi r24,lo8(11)
 225 0022 0E94 0000 		call SPI_transfer
 226               	.LVL15:
  70:spi_flash.c   ****     SPI_transfer(addr >> 16);
 227               		.loc 1 70 0
 228 0026 8E2D      		mov r24,r14
 229 0028 0E94 0000 		call SPI_transfer
 230               	.LVL16:
  71:spi_flash.c   ****     SPI_transfer(addr >> 8);
 231               		.loc 1 71 0
 232 002c 8D2F      		mov r24,r29
 233 002e 0E94 0000 		call SPI_transfer
 234               	.LVL17:
  72:spi_flash.c   ****     SPI_transfer(addr);
 235               		.loc 1 72 0
 236 0032 8C2F      		mov r24,r28
 237 0034 0E94 0000 		call SPI_transfer
 238               	.LVL18:
  73:spi_flash.c   ****     SPI_transfer(0); //"dont care"
 239               		.loc 1 73 0
 240 0038 80E0      		ldi r24,0
 241 003a 0E94 0000 		call SPI_transfer
 242               	.LVL19:
 243 003e CF2D      		mov r28,r15
 244 0040 D12F      		mov r29,r17
 245 0042 0C0F      		add r16,r28
 246 0044 1D2F      		mov r17,r29
 247 0046 111D      		adc r17,__zero_reg__
 248               	.LVL20:
 249               	.L12:
 250               	.LBB2:
  74:spi_flash.c   ****     
  75:spi_flash.c   ****     for (uint8_t i = 0; i < len; ++i)
 251               		.loc 1 75 0 discriminator 1
 252 0048 C017      		cp r28,r16
 253 004a D107      		cpc r29,r17
 254 004c 01F4      		brne .L13
 255               	.LBE2:
  76:spi_flash.c   ****       ((uint8_t*) buf)[i] = SPI_transfer(0);
  77:spi_flash.c   ****     FLASH_UNSELECT
 256               		.loc 1 77 0
 257 004e 479A      		sbi 0x8,7
 258               	/* epilogue start */
  78:spi_flash.c   **** }
 259               		.loc 1 78 0
 260 0050 DF91      		pop r29
 261 0052 CF91      		pop r28
 262               	.LVL21:
 263 0054 1F91      		pop r17
 264 0056 0F91      		pop r16
 265 0058 FF90      		pop r15
 266 005a EF90      		pop r14
 267 005c 0895      		ret
 268               	.LVL22:
 269               	.L13:
 270               	.LBB3:
  76:spi_flash.c   ****       ((uint8_t*) buf)[i] = SPI_transfer(0);
 271               		.loc 1 76 0 discriminator 3
 272 005e 80E0      		ldi r24,0
 273 0060 0E94 0000 		call SPI_transfer
 274               	.LVL23:
 275 0064 8993      		st Y+,r24
 276               	.LVL24:
 277 0066 00C0      		rjmp .L12
 278               	.LBE3:
 279               		.cfi_endproc
 280               	.LFE7:
 282               		.section	.text.FLASH_readByte,"ax",@progbits
 283               	.global	FLASH_readByte
 285               	FLASH_readByte:
 286               	.LFB8:
  79:spi_flash.c   **** 
  80:spi_flash.c   **** /* Read one byte from SPI flash with giving the address.
  81:spi_flash.c   ****  *  Function return the read data from this address 
  82:spi_flash.c   ****  */
  83:spi_flash.c   **** uint8_t FLASH_readByte(uint32_t addr) {
 287               		.loc 1 83 0
 288               		.cfi_startproc
 289               	.LVL25:
 290 0000 1F93      		push r17
 291               	.LCFI8:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 17, -2
 294 0002 CF93      		push r28
 295               	.LCFI9:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 28, -3
 298 0004 DF93      		push r29
 299               	.LCFI10:
 300               		.cfi_def_cfa_offset 5
 301               		.cfi_offset 29, -4
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 304               	/* stack size = 3 */
 305               	.L__stack_usage = 3
 306 0006 EB01      		movw r28,r22
 307 0008 182F      		mov r17,r24
 308               	.LVL26:
 309               	.L16:
  84:spi_flash.c   **** 
  85:spi_flash.c   ****   while(FLASH_busy());
 310               		.loc 1 85 0 discriminator 1
 311 000a 0E94 0000 		call FLASH_busy
 312               	.LVL27:
 313 000e 8111      		cpse r24,__zero_reg__
 314 0010 00C0      		rjmp .L16
  86:spi_flash.c   ****   FLASH_SELECT
 315               		.loc 1 86 0
 316 0012 4798      		cbi 0x8,7
  87:spi_flash.c   ****   SPI_transfer(SPIFLASH_READ_DATA);
 317               		.loc 1 87 0
 318 0014 83E0      		ldi r24,lo8(3)
 319 0016 0E94 0000 		call SPI_transfer
 320               	.LVL28:
  88:spi_flash.c   ****   SPI_transfer((addr >> 16) & 0xFF);
 321               		.loc 1 88 0
 322 001a 812F      		mov r24,r17
 323 001c 0E94 0000 		call SPI_transfer
 324               	.LVL29:
  89:spi_flash.c   ****   SPI_transfer((addr >> 8) & 0xFF);
 325               		.loc 1 89 0
 326 0020 8D2F      		mov r24,r29
 327 0022 0E94 0000 		call SPI_transfer
 328               	.LVL30:
  90:spi_flash.c   ****   SPI_transfer(addr & 0xFF);
 329               		.loc 1 90 0
 330 0026 8C2F      		mov r24,r28
 331 0028 0E94 0000 		call SPI_transfer
 332               	.LVL31:
  91:spi_flash.c   **** 
  92:spi_flash.c   ****   uint8_t result = SPI_transfer(0);
 333               		.loc 1 92 0
 334 002c 80E0      		ldi r24,0
 335 002e 0E94 0000 		call SPI_transfer
 336               	.LVL32:
  93:spi_flash.c   ****   FLASH_UNSELECT
 337               		.loc 1 93 0
 338 0032 479A      		sbi 0x8,7
 339               	/* epilogue start */
  94:spi_flash.c   **** 
  95:spi_flash.c   ****   return result;
  96:spi_flash.c   **** }
 340               		.loc 1 96 0
 341 0034 DF91      		pop r29
 342 0036 CF91      		pop r28
 343 0038 1F91      		pop r17
 344 003a 0895      		ret
 345               		.cfi_endproc
 346               	.LFE8:
 348               		.text
 349               	.Letext0:
 350               		.file 2 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 spi_flash.c
     /tmp/ccTvmzNq.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccTvmzNq.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccTvmzNq.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccTvmzNq.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccTvmzNq.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccTvmzNq.s:13     .text.SPI_transfer:0000000000000000 SPI_transfer
     /tmp/ccTvmzNq.s:48     .text.FLASH_busy:0000000000000000 FLASH_busy
     /tmp/ccTvmzNq.s:79     .text.readDeviceId:0000000000000000 readDeviceId
     /tmp/ccTvmzNq.s:131    .text.SPI_init:0000000000000000 SPI_init
     /tmp/ccTvmzNq.s:176    .text.Flash_readByteArray:0000000000000000 Flash_readByteArray
     /tmp/ccTvmzNq.s:285    .text.FLASH_readByte:0000000000000000 FLASH_readByte

NO UNDEFINED SYMBOLS
