   1               		.file	"aes.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.AddRoundKey,"ax",@progbits
  12               	AddRoundKey:
  13               	.LFB5:
  14               		.file 1 "aes.c"
   1:aes.c         **** #include "aes.h"
   2:aes.c         **** #include "spi_flash.h"
   3:aes.c         **** 
   4:aes.c         **** uint8_t key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0
   5:aes.c         **** uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0
   6:aes.c         **** 
   7:aes.c         **** 
   8:aes.c         **** /* ----------------- ENCRYPTION ALGORITHM ------------------------- */
   9:aes.c         **** 
  10:aes.c         **** // This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the
  11:aes.c         **** static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
  12:aes.c         **** {
  13:aes.c         ****   unsigned i, j, k;
  14:aes.c         ****   uint8_t tempa[4]; // Used for the column/row operations
  15:aes.c         ****   
  16:aes.c         ****   // The first round key is the key itself.
  17:aes.c         ****   for (i = 0; i < Nk; ++i)
  18:aes.c         ****   {
  19:aes.c         ****     RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
  20:aes.c         ****     RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
  21:aes.c         ****     RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
  22:aes.c         ****     RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
  23:aes.c         ****   }
  24:aes.c         **** 
  25:aes.c         ****   // All other round keys are found from the previous round keys.
  26:aes.c         ****   for (i = Nk; i < Nb * (Nr + 1); ++i)
  27:aes.c         ****   {
  28:aes.c         ****     {
  29:aes.c         ****       k = (i - 1) * 4;
  30:aes.c         ****       tempa[0]=RoundKey[k + 0];
  31:aes.c         ****       tempa[1]=RoundKey[k + 1];
  32:aes.c         ****       tempa[2]=RoundKey[k + 2];
  33:aes.c         ****       tempa[3]=RoundKey[k + 3];
  34:aes.c         **** 
  35:aes.c         ****     }
  36:aes.c         **** 
  37:aes.c         ****     if (i % Nk == 0)
  38:aes.c         ****     {
  39:aes.c         ****       // This function shifts the 4 bytes in a word to the left once.
  40:aes.c         ****       // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
  41:aes.c         **** 
  42:aes.c         ****       // Function RotWord()
  43:aes.c         ****       {
  44:aes.c         ****         const uint8_t u8tmp = tempa[0];
  45:aes.c         ****         tempa[0] = tempa[1];
  46:aes.c         ****         tempa[1] = tempa[2];
  47:aes.c         ****         tempa[2] = tempa[3];
  48:aes.c         ****         tempa[3] = u8tmp;
  49:aes.c         ****       }
  50:aes.c         **** 
  51:aes.c         ****       // SubWord() is a function that takes a four-byte input word and 
  52:aes.c         ****       // applies the S-box to each of the four bytes to produce an output word.
  53:aes.c         **** 
  54:aes.c         ****       // Function Subword()
  55:aes.c         ****       {
  56:aes.c         ****         tempa[0] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[0]); //getSBoxValue(tempa[0]);
  57:aes.c         ****         tempa[1] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[1]);//getSBoxValue(tempa[1]);
  58:aes.c         ****         tempa[2] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[2]);//getSBoxValue(tempa[2]);
  59:aes.c         ****         tempa[3] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[3]);//getSBoxValue(tempa[3]);
  60:aes.c         ****       }
  61:aes.c         **** 
  62:aes.c         ****       tempa[0] = tempa[0] ^ Rcon[i/Nk];
  63:aes.c         ****     }
  64:aes.c         ****     j = i * 4; k=(i - Nk) * 4;
  65:aes.c         ****     RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
  66:aes.c         ****     RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
  67:aes.c         ****     RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
  68:aes.c         ****     RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
  69:aes.c         ****   }
  70:aes.c         **** }
  71:aes.c         **** 
  72:aes.c         **** void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
  73:aes.c         **** {
  74:aes.c         ****   KeyExpansion(ctx->RoundKey, key);
  75:aes.c         ****   memcpy (ctx->Iv, iv, AES_BLOCKLEN);
  76:aes.c         **** }
  77:aes.c         **** 
  78:aes.c         **** 
  79:aes.c         **** // This function adds the round key to state.
  80:aes.c         **** // The round key is added to the state by an XOR function.
  81:aes.c         **** static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
  82:aes.c         **** {
  15               		.loc 1 82 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 1F93      		push r17
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 17, -2
  22 0002 CF93      		push r28
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 28, -3
  26 0004 DF93      		push r29
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 29, -4
  30               	/* prologue: function */
  31               	/* frame size = 0 */
  32               	/* stack size = 3 */
  33               	.L__stack_usage = 3
  34               	.LVL1:
  35 0006 20E1      		ldi r18,lo8(16)
  36 0008 829F      		mul r24,r18
  37 000a C001      		movw r24,r0
  38 000c 1124      		clr __zero_reg__
  39               	.LVL2:
  40 000e 480F      		add r20,r24
  41 0010 591F      		adc r21,r25
  42               	.LVL3:
  83:aes.c         ****   uint8_t i,j;
  84:aes.c         ****   for (i = 0; i < 4; ++i)
  85:aes.c         ****   {
  86:aes.c         ****     for (j = 0; j < 4; ++j)
  87:aes.c         ****     {
  88:aes.c         ****       (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
  43               		.loc 1 88 0
  44 0012 30E0      		ldi r19,0
  45 0014 20E0      		ldi r18,0
  46               	.LVL4:
  47               	.L2:
  48 0016 FB01      		movw r30,r22
  49 0018 E20F      		add r30,r18
  50 001a F31F      		adc r31,r19
  51 001c D901      		movw r26,r18
  52 001e A40F      		add r26,r20
  53 0020 B51F      		adc r27,r21
  86:aes.c         ****     {
  54               		.loc 1 86 0
  55 0022 90E0      		ldi r25,0
  56               	.LVL5:
  57               	.L3:
  58               		.loc 1 88 0 discriminator 3
  59 0024 8191      		ld r24,Z+
  60 0026 1D91      		ld r17,X+
  61 0028 EF01      		movw r28,r30
  62 002a 2197      		sbiw r28,1
  63 002c 8127      		eor r24,r17
  64 002e 8883      		st Y,r24
  86:aes.c         ****     {
  65               		.loc 1 86 0 discriminator 3
  66 0030 9F5F      		subi r25,lo8(-(1))
  67               	.LVL6:
  68 0032 9430      		cpi r25,lo8(4)
  69 0034 01F4      		brne .L3
  70 0036 2C5F      		subi r18,-4
  71 0038 3F4F      		sbci r19,-1
  84:aes.c         ****   {
  72               		.loc 1 84 0 discriminator 2
  73 003a 2031      		cpi r18,16
  74 003c 3105      		cpc r19,__zero_reg__
  75 003e 01F4      		brne .L2
  76               	/* epilogue start */
  89:aes.c         ****     }
  90:aes.c         ****   }
  91:aes.c         **** }
  77               		.loc 1 91 0
  78 0040 DF91      		pop r29
  79 0042 CF91      		pop r28
  80 0044 1F91      		pop r17
  81 0046 0895      		ret
  82               		.cfi_endproc
  83               	.LFE5:
  85               		.section	.text.xtime,"ax",@progbits
  87               	xtime:
  88               	.LFB6:
  92:aes.c         **** 
  93:aes.c         **** static uint8_t xtime(uint8_t x)
  94:aes.c         **** {
  89               		.loc 1 94 0
  90               		.cfi_startproc
  91               	.LVL7:
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  95:aes.c         ****   return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
  96               		.loc 1 95 0
  97 0000 982F      		mov r25,r24
  98 0002 991F      		rol r25
  99 0004 9927      		clr r25
 100 0006 991F      		rol r25
 101 0008 2BE1      		ldi r18,lo8(27)
 102 000a 929F      		mul r25,r18
 103 000c 902D      		mov r25,r0
 104 000e 1124      		clr r1
 105 0010 880F      		lsl r24
 106               	.LVL8:
  96:aes.c         **** }
 107               		.loc 1 96 0
 108 0012 8927      		eor r24,r25
 109               	/* epilogue start */
 110 0014 0895      		ret
 111               		.cfi_endproc
 112               	.LFE6:
 114               		.section	.text.InvSubBytes,"ax",@progbits
 116               	InvSubBytes:
 117               	.LFB8:
  97:aes.c         **** 
  98:aes.c         **** // Multiply is used to multiply numbers in the field GF(2^8)
  99:aes.c         **** // Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary
 100:aes.c         **** //       The compiler seems to be able to vectorize the operation better this way.
 101:aes.c         **** //       See https://github.com/kokke/tiny-AES-c/pull/34
 102:aes.c         **** #if MULTIPLY_AS_A_FUNCTION
 103:aes.c         **** static uint8_t Multiply(uint8_t x, uint8_t y)
 104:aes.c         **** {
 105:aes.c         ****   return (((y & 1) * x) ^
 106:aes.c         ****        ((y>>1 & 1) * xtime(x)) ^
 107:aes.c         ****        ((y>>2 & 1) * xtime(xtime(x))) ^
 108:aes.c         ****        ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^
 109:aes.c         ****        ((y>>4 & 1) * xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted *
 110:aes.c         ****   }
 111:aes.c         **** #else
 112:aes.c         **** #define Multiply(x, y)                                \
 113:aes.c         ****       (  ((y & 1) * x) ^                              \
 114:aes.c         ****       ((y>>1 & 1) * xtime(x)) ^                       \
 115:aes.c         ****       ((y>>2 & 1) * xtime(xtime(x))) ^                \
 116:aes.c         ****       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
 117:aes.c         ****       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \
 118:aes.c         **** 
 119:aes.c         **** #endif
 120:aes.c         **** 
 121:aes.c         **** // MixColumns function mixes the columns of the state matrix.
 122:aes.c         **** // The method used to multiply may be difficult to understand for the inexperienced.
 123:aes.c         **** // Please use the references to gain more information.
 124:aes.c         **** static void InvMixColumns(state_t* state)
 125:aes.c         **** {
 126:aes.c         ****   int i;
 127:aes.c         ****   uint8_t a, b, c, d;
 128:aes.c         ****   for (i = 0; i < 4; ++i)
 129:aes.c         ****   { 
 130:aes.c         ****     a = (*state)[i][0];
 131:aes.c         ****     b = (*state)[i][1];
 132:aes.c         ****     c = (*state)[i][2];
 133:aes.c         ****     d = (*state)[i][3];
 134:aes.c         **** 
 135:aes.c         ****     (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
 136:aes.c         ****     (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
 137:aes.c         ****     (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
 138:aes.c         ****     (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
 139:aes.c         ****   }
 140:aes.c         **** }
 141:aes.c         **** 
 142:aes.c         **** 
 143:aes.c         **** // The SubBytes Function Substitutes the values in the
 144:aes.c         **** // state matrix with values in an S-box.
 145:aes.c         **** static void InvSubBytes(state_t* state)
 146:aes.c         **** {
 118               		.loc 1 146 0
 119               		.cfi_startproc
 120               	.LVL9:
 121 0000 EF92      		push r14
 122               	.LCFI3:
 123               		.cfi_def_cfa_offset 3
 124               		.cfi_offset 14, -2
 125 0002 FF92      		push r15
 126               	.LCFI4:
 127               		.cfi_def_cfa_offset 4
 128               		.cfi_offset 15, -3
 129 0004 0F93      		push r16
 130               	.LCFI5:
 131               		.cfi_def_cfa_offset 5
 132               		.cfi_offset 16, -4
 133 0006 1F93      		push r17
 134               	.LCFI6:
 135               		.cfi_def_cfa_offset 6
 136               		.cfi_offset 17, -5
 137 0008 CF93      		push r28
 138               	.LCFI7:
 139               		.cfi_def_cfa_offset 7
 140               		.cfi_offset 28, -6
 141 000a DF93      		push r29
 142               	.LCFI8:
 143               		.cfi_def_cfa_offset 8
 144               		.cfi_offset 29, -7
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 6 */
 148               	.L__stack_usage = 6
 149 000c 8C01      		movw r16,r24
 150               	.LVL10:
 147:aes.c         ****   uint8_t i, j;
 148:aes.c         ****   for (i = 0; i < 4; ++i)
 149:aes.c         ****   {
 150:aes.c         ****     for (j = 0; j < 4; ++j)
 151               		.loc 1 150 0
 152 000e 84E0      		ldi r24,lo8(4)
 153 0010 E82E      		mov r14,r24
 154               	.LVL11:
 155               	.L8:
 146:aes.c         ****   uint8_t i, j;
 156               		.loc 1 146 0
 157 0012 E801      		movw r28,r16
 158               		.loc 1 150 0
 159 0014 F12C      		mov r15,__zero_reg__
 160               	.LVL12:
 161               	.L9:
 151:aes.c         ****     {
 152:aes.c         ****       (*state)[j][i] = FLASH_readByte(SECTOR_RSBOX_VALUE + (*state)[j][i]); //getSBoxInvert((*state
 162               		.loc 1 152 0 discriminator 3
 163 0016 6881      		ld r22,Y
 164 0018 70E0      		ldi r23,0
 165 001a 7F5E      		subi r23,-17
 166 001c 072E      		mov __tmp_reg__,r23
 167 001e 000C      		lsl r0
 168 0020 880B      		sbc r24,r24
 169 0022 990B      		sbc r25,r25
 170 0024 0E94 0000 		call FLASH_readByte
 171               	.LVL13:
 172 0028 8883      		st Y,r24
 150:aes.c         ****     {
 173               		.loc 1 150 0 discriminator 3
 174 002a F394      		inc r15
 175               	.LVL14:
 176 002c 2496      		adiw r28,4
 177 002e 84E0      		ldi r24,lo8(4)
 178 0030 F812      		cpse r15,r24
 179 0032 00C0      		rjmp .L9
 180               	.LVL15:
 181 0034 EA94      		dec r14
 182 0036 0F5F      		subi r16,-1
 183 0038 1F4F      		sbci r17,-1
 184               	.LVL16:
 148:aes.c         ****   {
 185               		.loc 1 148 0 discriminator 2
 186 003a E110      		cpse r14,__zero_reg__
 187 003c 00C0      		rjmp .L8
 188               	/* epilogue start */
 153:aes.c         ****     }
 154:aes.c         ****   }
 155:aes.c         **** }
 189               		.loc 1 155 0
 190 003e DF91      		pop r29
 191 0040 CF91      		pop r28
 192 0042 1F91      		pop r17
 193 0044 0F91      		pop r16
 194               	.LVL17:
 195 0046 FF90      		pop r15
 196               	.LVL18:
 197 0048 EF90      		pop r14
 198 004a 0895      		ret
 199               		.cfi_endproc
 200               	.LFE8:
 202               		.section	.text.AES_init_ctx_iv,"ax",@progbits
 203               	.global	AES_init_ctx_iv
 205               	AES_init_ctx_iv:
 206               	.LFB4:
  73:aes.c         ****   KeyExpansion(ctx->RoundKey, key);
 207               		.loc 1 73 0
 208               		.cfi_startproc
 209               	.LVL19:
 210 0000 7F92      		push r7
 211               	.LCFI9:
 212               		.cfi_def_cfa_offset 3
 213               		.cfi_offset 7, -2
 214 0002 8F92      		push r8
 215               	.LCFI10:
 216               		.cfi_def_cfa_offset 4
 217               		.cfi_offset 8, -3
 218 0004 9F92      		push r9
 219               	.LCFI11:
 220               		.cfi_def_cfa_offset 5
 221               		.cfi_offset 9, -4
 222 0006 AF92      		push r10
 223               	.LCFI12:
 224               		.cfi_def_cfa_offset 6
 225               		.cfi_offset 10, -5
 226 0008 BF92      		push r11
 227               	.LCFI13:
 228               		.cfi_def_cfa_offset 7
 229               		.cfi_offset 11, -6
 230 000a CF92      		push r12
 231               	.LCFI14:
 232               		.cfi_def_cfa_offset 8
 233               		.cfi_offset 12, -7
 234 000c DF92      		push r13
 235               	.LCFI15:
 236               		.cfi_def_cfa_offset 9
 237               		.cfi_offset 13, -8
 238 000e EF92      		push r14
 239               	.LCFI16:
 240               		.cfi_def_cfa_offset 10
 241               		.cfi_offset 14, -9
 242 0010 FF92      		push r15
 243               	.LCFI17:
 244               		.cfi_def_cfa_offset 11
 245               		.cfi_offset 15, -10
 246 0012 0F93      		push r16
 247               	.LCFI18:
 248               		.cfi_def_cfa_offset 12
 249               		.cfi_offset 16, -11
 250 0014 1F93      		push r17
 251               	.LCFI19:
 252               		.cfi_def_cfa_offset 13
 253               		.cfi_offset 17, -12
 254 0016 CF93      		push r28
 255               	.LCFI20:
 256               		.cfi_def_cfa_offset 14
 257               		.cfi_offset 28, -13
 258 0018 DF93      		push r29
 259               	.LCFI21:
 260               		.cfi_def_cfa_offset 15
 261               		.cfi_offset 29, -14
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 13 */
 265               	.L__stack_usage = 13
 266 001a 8C01      		movw r16,r24
 267 001c 7A01      		movw r14,r20
 268               	.LVL20:
 269 001e FB01      		movw r30,r22
 270 0020 EC01      		movw r28,r24
 271 0022 CB01      		movw r24,r22
 272               	.LVL21:
 273 0024 4096      		adiw r24,16
  74:aes.c         ****   memcpy (ctx->Iv, iv, AES_BLOCKLEN);
 274               		.loc 1 74 0
 275 0026 D801      		movw r26,r16
 276               	.LVL22:
 277               	.L13:
 278               	.LBB4:
 279               	.LBB5:
  19:aes.c         ****     RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
 280               		.loc 1 19 0
 281 0028 2081      		ld r18,Z
 282 002a 2C93      		st X,r18
  20:aes.c         ****     RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
 283               		.loc 1 20 0
 284 002c 2181      		ldd r18,Z+1
 285 002e 1196      		adiw r26,1
 286 0030 2C93      		st X,r18
 287 0032 1197      		sbiw r26,1
  21:aes.c         ****     RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
 288               		.loc 1 21 0
 289 0034 2281      		ldd r18,Z+2
 290 0036 1296      		adiw r26,2
 291 0038 2C93      		st X,r18
 292 003a 1297      		sbiw r26,2
  22:aes.c         ****   }
 293               		.loc 1 22 0
 294 003c 2381      		ldd r18,Z+3
 295 003e 1396      		adiw r26,3
 296 0040 2C93      		st X,r18
 297 0042 1397      		sbiw r26,3
 298 0044 3496      		adiw r30,4
 299 0046 1496      		adiw r26,4
  17:aes.c         ****   {
 300               		.loc 1 17 0
 301 0048 E817      		cp r30,r24
 302 004a F907      		cpc r31,r25
 303 004c 01F4      		brne .L13
  26:aes.c         ****   {
 304               		.loc 1 26 0
 305 004e 94E0      		ldi r25,lo8(4)
 306 0050 C92E      		mov r12,r25
 307 0052 D12C      		mov r13,__zero_reg__
 308               	.LVL23:
 309               	.L15:
  30:aes.c         ****       tempa[1]=RoundKey[k + 1];
 310               		.loc 1 30 0
 311 0054 8C84      		ldd r8,Y+12
 312               	.LVL24:
  31:aes.c         ****       tempa[2]=RoundKey[k + 2];
 313               		.loc 1 31 0
 314 0056 AD84      		ldd r10,Y+13
 315               	.LVL25:
  32:aes.c         ****       tempa[3]=RoundKey[k + 3];
 316               		.loc 1 32 0
 317 0058 BE84      		ldd r11,Y+14
 318               	.LVL26:
  33:aes.c         **** 
 319               		.loc 1 33 0
 320 005a 7F84      		ldd r7,Y+15
 321               	.LVL27:
  37:aes.c         ****     {
 322               		.loc 1 37 0
 323 005c C601      		movw r24,r12
 324 005e 8370      		andi r24,3
 325 0060 9927      		clr r25
 326 0062 892B      		or r24,r25
 327 0064 01F4      		brne .L14
 328               	.LVL28:
  56:aes.c         ****         tempa[1] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[1]);//getSBoxValue(tempa[1]);
 329               		.loc 1 56 0
 330 0066 6A2D      		mov r22,r10
 331 0068 70E0      		ldi r23,0
 332 006a 705F      		subi r23,-16
 333 006c 072E      		mov __tmp_reg__,r23
 334 006e 000C      		lsl r0
 335 0070 880B      		sbc r24,r24
 336 0072 990B      		sbc r25,r25
 337 0074 0E94 0000 		call FLASH_readByte
 338               	.LVL29:
 339 0078 982E      		mov r9,r24
 340               	.LVL30:
  57:aes.c         ****         tempa[2] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[2]);//getSBoxValue(tempa[2]);
 341               		.loc 1 57 0
 342 007a 6B2D      		mov r22,r11
 343 007c 70E0      		ldi r23,0
 344 007e 705F      		subi r23,-16
 345 0080 072E      		mov __tmp_reg__,r23
 346 0082 000C      		lsl r0
 347 0084 880B      		sbc r24,r24
 348 0086 990B      		sbc r25,r25
 349 0088 0E94 0000 		call FLASH_readByte
 350               	.LVL31:
 351 008c A82E      		mov r10,r24
 352               	.LVL32:
  58:aes.c         ****         tempa[3] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[3]);//getSBoxValue(tempa[3]);
 353               		.loc 1 58 0
 354 008e 672D      		mov r22,r7
 355 0090 70E0      		ldi r23,0
 356 0092 705F      		subi r23,-16
 357 0094 072E      		mov __tmp_reg__,r23
 358 0096 000C      		lsl r0
 359 0098 880B      		sbc r24,r24
 360 009a 990B      		sbc r25,r25
 361 009c 0E94 0000 		call FLASH_readByte
 362               	.LVL33:
 363 00a0 B82E      		mov r11,r24
 364               	.LVL34:
  59:aes.c         ****       }
 365               		.loc 1 59 0
 366 00a2 682D      		mov r22,r8
 367 00a4 70E0      		ldi r23,0
 368 00a6 705F      		subi r23,-16
 369 00a8 072E      		mov __tmp_reg__,r23
 370 00aa 000C      		lsl r0
 371 00ac 880B      		sbc r24,r24
 372 00ae 990B      		sbc r25,r25
 373 00b0 0E94 0000 		call FLASH_readByte
 374               	.LVL35:
 375 00b4 782E      		mov r7,r24
 376               	.LVL36:
  62:aes.c         ****     }
 377               		.loc 1 62 0
 378 00b6 F601      		movw r30,r12
 379 00b8 F695      		lsr r31
 380 00ba E795      		ror r30
 381 00bc F695      		lsr r31
 382 00be E795      		ror r30
 383 00c0 E050      		subi r30,lo8(-(Rcon))
 384 00c2 F040      		sbci r31,hi8(-(Rcon))
 385 00c4 6081      		ld r22,Z
 386 00c6 892C      		mov r8,r9
 387               	.LVL37:
 388 00c8 8626      		eor r8,r22
 389               	.LVL38:
 390               	.L14:
  65:aes.c         ****     RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
 391               		.loc 1 65 0
 392 00ca 6881      		ld r22,Y
 393 00cc 6825      		eor r22,r8
 394 00ce 688B      		std Y+16,r22
  66:aes.c         ****     RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
 395               		.loc 1 66 0
 396 00d0 6981      		ldd r22,Y+1
 397 00d2 A626      		eor r10,r22
 398               	.LVL39:
 399 00d4 A98A      		std Y+17,r10
  67:aes.c         ****     RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
 400               		.loc 1 67 0
 401 00d6 6A81      		ldd r22,Y+2
 402 00d8 B626      		eor r11,r22
 403               	.LVL40:
 404 00da BA8A      		std Y+18,r11
  68:aes.c         ****   }
 405               		.loc 1 68 0
 406 00dc 6B81      		ldd r22,Y+3
 407 00de 6725      		eor r22,r7
 408 00e0 6B8B      		std Y+19,r22
  26:aes.c         ****   {
 409               		.loc 1 26 0
 410 00e2 8FEF      		ldi r24,-1
 411 00e4 C81A      		sub r12,r24
 412 00e6 D80A      		sbc r13,r24
 413               	.LVL41:
 414 00e8 2496      		adiw r28,4
 415               	.LVL42:
 416 00ea 8CE2      		ldi r24,44
 417 00ec C816      		cp r12,r24
 418 00ee D104      		cpc r13,__zero_reg__
 419 00f0 01F0      		breq .+2
 420 00f2 00C0      		rjmp .L15
 421               	.LVL43:
 422               	.LBE5:
 423               	.LBE4:
  75:aes.c         **** }
 424               		.loc 1 75 0
 425 00f4 D801      		movw r26,r16
 426 00f6 A055      		subi r26,80
 427 00f8 BF4F      		sbci r27,-1
 428 00fa 80E1      		ldi r24,lo8(16)
 429 00fc F701      		movw r30,r14
 430               		0:
 431 00fe 0190      		ld r0,Z+
 432 0100 0D92      		st X+,r0
 433 0102 8A95      		dec r24
 434 0104 01F4      		brne 0b
 435               	/* epilogue start */
  76:aes.c         **** 
 436               		.loc 1 76 0
 437 0106 DF91      		pop r29
 438 0108 CF91      		pop r28
 439 010a 1F91      		pop r17
 440 010c 0F91      		pop r16
 441               	.LVL44:
 442 010e FF90      		pop r15
 443 0110 EF90      		pop r14
 444               	.LVL45:
 445 0112 DF90      		pop r13
 446 0114 CF90      		pop r12
 447 0116 BF90      		pop r11
 448 0118 AF90      		pop r10
 449 011a 9F90      		pop r9
 450 011c 8F90      		pop r8
 451 011e 7F90      		pop r7
 452 0120 0895      		ret
 453               		.cfi_endproc
 454               	.LFE4:
 456               		.section	.text.AES_CBC_decrypt_buffer,"ax",@progbits
 457               	.global	AES_CBC_decrypt_buffer
 459               	AES_CBC_decrypt_buffer:
 460               	.LFB12:
 156:aes.c         **** 
 157:aes.c         **** static void InvShiftRows(state_t* state)
 158:aes.c         **** {
 159:aes.c         ****   uint8_t temp;
 160:aes.c         **** 
 161:aes.c         ****   // Rotate first row 1 columns to right  
 162:aes.c         ****   temp = (*state)[3][1];
 163:aes.c         ****   (*state)[3][1] = (*state)[2][1];
 164:aes.c         ****   (*state)[2][1] = (*state)[1][1];
 165:aes.c         ****   (*state)[1][1] = (*state)[0][1];
 166:aes.c         ****   (*state)[0][1] = temp;
 167:aes.c         **** 
 168:aes.c         ****   // Rotate second row 2 columns to right 
 169:aes.c         ****   temp = (*state)[0][2];
 170:aes.c         ****   (*state)[0][2] = (*state)[2][2];
 171:aes.c         ****   (*state)[2][2] = temp;
 172:aes.c         **** 
 173:aes.c         ****   temp = (*state)[1][2];
 174:aes.c         ****   (*state)[1][2] = (*state)[3][2];
 175:aes.c         ****   (*state)[3][2] = temp;
 176:aes.c         **** 
 177:aes.c         ****   // Rotate third row 3 columns to right
 178:aes.c         ****   temp = (*state)[0][3];
 179:aes.c         ****   (*state)[0][3] = (*state)[1][3];
 180:aes.c         ****   (*state)[1][3] = (*state)[2][3];
 181:aes.c         ****   (*state)[2][3] = (*state)[3][3];
 182:aes.c         ****   (*state)[3][3] = temp;
 183:aes.c         **** }
 184:aes.c         **** 
 185:aes.c         **** static void InvCipher(state_t* state, const uint8_t* RoundKey)
 186:aes.c         **** {
 187:aes.c         ****   uint8_t round = 0;
 188:aes.c         **** 
 189:aes.c         ****   // Add the First round key to the state before starting the rounds.
 190:aes.c         ****   AddRoundKey(Nr, state, RoundKey); 
 191:aes.c         **** 
 192:aes.c         ****   // There will be Nr rounds.
 193:aes.c         ****   // The first Nr-1 rounds are identical.
 194:aes.c         ****   // These Nr-1 rounds are executed in the loop below.
 195:aes.c         ****   for (round = (Nr - 1); round > 0; --round)
 196:aes.c         ****   {
 197:aes.c         ****     InvShiftRows(state);
 198:aes.c         ****     InvSubBytes(state);
 199:aes.c         ****     AddRoundKey(round, state, RoundKey);
 200:aes.c         ****     InvMixColumns(state);
 201:aes.c         ****   }
 202:aes.c         ****   
 203:aes.c         ****   // The last round is given below.
 204:aes.c         ****   // The MixColumns function is not here in the last round.
 205:aes.c         ****   InvShiftRows(state);
 206:aes.c         ****   InvSubBytes(state);
 207:aes.c         ****   AddRoundKey(0, state, RoundKey);
 208:aes.c         **** }
 209:aes.c         **** 
 210:aes.c         **** 
 211:aes.c         **** static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
 212:aes.c         **** {
 213:aes.c         ****   uint8_t i;
 214:aes.c         ****   for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
 215:aes.c         ****   {
 216:aes.c         ****     buf[i] ^= Iv[i];
 217:aes.c         ****   }
 218:aes.c         **** }
 219:aes.c         **** 
 220:aes.c         **** void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf,  uint32_t length)
 221:aes.c         **** {
 461               		.loc 1 221 0
 462               		.cfi_startproc
 463               	.LVL46:
 464 0000 2F92      		push r2
 465               	.LCFI22:
 466               		.cfi_def_cfa_offset 3
 467               		.cfi_offset 2, -2
 468 0002 3F92      		push r3
 469               	.LCFI23:
 470               		.cfi_def_cfa_offset 4
 471               		.cfi_offset 3, -3
 472 0004 4F92      		push r4
 473               	.LCFI24:
 474               		.cfi_def_cfa_offset 5
 475               		.cfi_offset 4, -4
 476 0006 5F92      		push r5
 477               	.LCFI25:
 478               		.cfi_def_cfa_offset 6
 479               		.cfi_offset 5, -5
 480 0008 6F92      		push r6
 481               	.LCFI26:
 482               		.cfi_def_cfa_offset 7
 483               		.cfi_offset 6, -6
 484 000a 7F92      		push r7
 485               	.LCFI27:
 486               		.cfi_def_cfa_offset 8
 487               		.cfi_offset 7, -7
 488 000c 8F92      		push r8
 489               	.LCFI28:
 490               		.cfi_def_cfa_offset 9
 491               		.cfi_offset 8, -8
 492 000e 9F92      		push r9
 493               	.LCFI29:
 494               		.cfi_def_cfa_offset 10
 495               		.cfi_offset 9, -9
 496 0010 AF92      		push r10
 497               	.LCFI30:
 498               		.cfi_def_cfa_offset 11
 499               		.cfi_offset 10, -10
 500 0012 BF92      		push r11
 501               	.LCFI31:
 502               		.cfi_def_cfa_offset 12
 503               		.cfi_offset 11, -11
 504 0014 CF92      		push r12
 505               	.LCFI32:
 506               		.cfi_def_cfa_offset 13
 507               		.cfi_offset 12, -12
 508 0016 DF92      		push r13
 509               	.LCFI33:
 510               		.cfi_def_cfa_offset 14
 511               		.cfi_offset 13, -13
 512 0018 EF92      		push r14
 513               	.LCFI34:
 514               		.cfi_def_cfa_offset 15
 515               		.cfi_offset 14, -14
 516 001a FF92      		push r15
 517               	.LCFI35:
 518               		.cfi_def_cfa_offset 16
 519               		.cfi_offset 15, -15
 520 001c 0F93      		push r16
 521               	.LCFI36:
 522               		.cfi_def_cfa_offset 17
 523               		.cfi_offset 16, -16
 524 001e 1F93      		push r17
 525               	.LCFI37:
 526               		.cfi_def_cfa_offset 18
 527               		.cfi_offset 17, -17
 528 0020 CF93      		push r28
 529               	.LCFI38:
 530               		.cfi_def_cfa_offset 19
 531               		.cfi_offset 28, -18
 532 0022 DF93      		push r29
 533               	.LCFI39:
 534               		.cfi_def_cfa_offset 20
 535               		.cfi_offset 29, -19
 536 0024 CDB7      		in r28,__SP_L__
 537 0026 DEB7      		in r29,__SP_H__
 538               	.LCFI40:
 539               		.cfi_def_cfa_register 28
 540 0028 A097      		sbiw r28,32
 541               	.LCFI41:
 542               		.cfi_def_cfa_offset 52
 543 002a 0FB6      		in __tmp_reg__,__SREG__
 544 002c F894      		cli
 545 002e DEBF      		out __SP_H__,r29
 546 0030 0FBE      		out __SREG__,__tmp_reg__
 547 0032 CDBF      		out __SP_L__,r28
 548               	/* prologue: function */
 549               	/* frame size = 32 */
 550               	/* stack size = 50 */
 551               	.L__stack_usage = 50
 552 0034 3C01      		movw r6,r24
 553 0036 7C8F      		std Y+28,r23
 554 0038 6B8F      		std Y+27,r22
 555 003a 2D8F      		std Y+29,r18
 556 003c 3E8F      		std Y+30,r19
 557 003e 4F8F      		std Y+31,r20
 558 0040 58A3      		std Y+32,r21
 559               	.LVL47:
 560 0042 9B01      		movw r18,r22
 561               	.LVL48:
 562 0044 205F      		subi r18,-16
 563 0046 3F4F      		sbci r19,-1
 564 0048 3A8F      		std Y+26,r19
 565 004a 298F      		std Y+25,r18
 222:aes.c         ****   uintptr_t i;
 223:aes.c         ****   uint8_t storeNextIv[AES_BLOCKLEN];
 224:aes.c         ****   for (i = 0; i < length; i += AES_BLOCKLEN)
 566               		.loc 1 224 0
 567 004c 8B01      		movw r16,r22
 568               	.LVL49:
 569               	.L19:
 570 004e 1C8B      		std Y+20,r17
 571 0050 0B8B      		std Y+19,r16
 572               	.LVL50:
 573               		.loc 1 224 0 is_stmt 0 discriminator 1
 574 0052 C801      		movw r24,r16
 575 0054 EB8D      		ldd r30,Y+27
 576 0056 FC8D      		ldd r31,Y+28
 577 0058 8E1B      		sub r24,r30
 578 005a 9F0B      		sbc r25,r31
 579               	.LVL51:
 580 005c B0E0      		ldi r27,0
 581 005e A0E0      		ldi r26,0
 582 0060 2D8D      		ldd r18,Y+29
 583 0062 3E8D      		ldd r19,Y+30
 584 0064 4F8D      		ldd r20,Y+31
 585 0066 58A1      		ldd r21,Y+32
 586 0068 8217      		cp r24,r18
 587 006a 9307      		cpc r25,r19
 588 006c A407      		cpc r26,r20
 589 006e B507      		cpc r27,r21
 590 0070 00F0      		brlo .L23
 591               	.LVL52:
 592               	/* epilogue start */
 225:aes.c         ****   {
 226:aes.c         ****     memcpy(storeNextIv, buf, AES_BLOCKLEN);
 227:aes.c         ****     InvCipher((state_t*)buf, ctx->RoundKey);
 228:aes.c         ****     XorWithIv(buf, ctx->Iv);
 229:aes.c         ****     memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
 230:aes.c         ****     buf += AES_BLOCKLEN;
 231:aes.c         ****   }
 232:aes.c         **** 
 233:aes.c         **** }
 593               		.loc 1 233 0 is_stmt 1
 594 0072 A096      		adiw r28,32
 595 0074 0FB6      		in __tmp_reg__,__SREG__
 596 0076 F894      		cli
 597 0078 DEBF      		out __SP_H__,r29
 598 007a 0FBE      		out __SREG__,__tmp_reg__
 599 007c CDBF      		out __SP_L__,r28
 600 007e DF91      		pop r29
 601 0080 CF91      		pop r28
 602 0082 1F91      		pop r17
 603 0084 0F91      		pop r16
 604               	.LVL53:
 605 0086 FF90      		pop r15
 606 0088 EF90      		pop r14
 607 008a DF90      		pop r13
 608 008c CF90      		pop r12
 609 008e BF90      		pop r11
 610 0090 AF90      		pop r10
 611 0092 9F90      		pop r9
 612 0094 8F90      		pop r8
 613 0096 7F90      		pop r7
 614 0098 6F90      		pop r6
 615               	.LVL54:
 616 009a 5F90      		pop r5
 617 009c 4F90      		pop r4
 618 009e 3F90      		pop r3
 619 00a0 2F90      		pop r2
 620 00a2 0895      		ret
 621               	.LVL55:
 622               	.L23:
 226:aes.c         ****     InvCipher((state_t*)buf, ctx->RoundKey);
 623               		.loc 1 226 0 discriminator 3
 624 00a4 80E1      		ldi r24,lo8(16)
 625               	.LVL56:
 626 00a6 F801      		movw r30,r16
 627 00a8 DE01      		movw r26,r28
 628 00aa 1196      		adiw r26,1
 629               		0:
 630 00ac 0190      		ld r0,Z+
 631 00ae 0D92      		st X+,r0
 632 00b0 8A95      		dec r24
 633 00b2 01F4      		brne 0b
 634               	.LVL57:
 635               	.LBB16:
 636               	.LBB17:
 190:aes.c         **** 
 637               		.loc 1 190 0 discriminator 3
 638 00b4 A301      		movw r20,r6
 639 00b6 B801      		movw r22,r16
 640 00b8 8AE0      		ldi r24,lo8(10)
 641 00ba 0E94 0000 		call AddRoundKey
 642               	.LVL58:
 195:aes.c         ****   {
 643               		.loc 1 195 0 discriminator 3
 644 00be 39E0      		ldi r19,lo8(9)
 645 00c0 398B      		std Y+17,r19
 646               	.LVL59:
 647               	.L21:
 648               	.LBB18:
 649               	.LBB19:
 162:aes.c         ****   (*state)[3][1] = (*state)[2][1];
 650               		.loc 1 162 0
 651 00c2 F801      		movw r30,r16
 652 00c4 8585      		ldd r24,Z+13
 653               	.LVL60:
 163:aes.c         ****   (*state)[2][1] = (*state)[1][1];
 654               		.loc 1 163 0
 655 00c6 9185      		ldd r25,Z+9
 656 00c8 9587      		std Z+13,r25
 164:aes.c         ****   (*state)[1][1] = (*state)[0][1];
 657               		.loc 1 164 0
 658 00ca 9581      		ldd r25,Z+5
 659 00cc 9187      		std Z+9,r25
 165:aes.c         ****   (*state)[0][1] = temp;
 660               		.loc 1 165 0
 661 00ce 9181      		ldd r25,Z+1
 662 00d0 9583      		std Z+5,r25
 166:aes.c         **** 
 663               		.loc 1 166 0
 664 00d2 8183      		std Z+1,r24
 169:aes.c         ****   (*state)[0][2] = (*state)[2][2];
 665               		.loc 1 169 0
 666 00d4 8281      		ldd r24,Z+2
 667               	.LVL61:
 170:aes.c         ****   (*state)[2][2] = temp;
 668               		.loc 1 170 0
 669 00d6 9285      		ldd r25,Z+10
 670 00d8 9283      		std Z+2,r25
 171:aes.c         **** 
 671               		.loc 1 171 0
 672 00da 8287      		std Z+10,r24
 173:aes.c         ****   (*state)[1][2] = (*state)[3][2];
 673               		.loc 1 173 0
 674 00dc 8681      		ldd r24,Z+6
 675               	.LVL62:
 174:aes.c         ****   (*state)[3][2] = temp;
 676               		.loc 1 174 0
 677 00de 9685      		ldd r25,Z+14
 678 00e0 9683      		std Z+6,r25
 175:aes.c         **** 
 679               		.loc 1 175 0
 680 00e2 8687      		std Z+14,r24
 178:aes.c         ****   (*state)[0][3] = (*state)[1][3];
 681               		.loc 1 178 0
 682 00e4 8381      		ldd r24,Z+3
 683               	.LVL63:
 179:aes.c         ****   (*state)[1][3] = (*state)[2][3];
 684               		.loc 1 179 0
 685 00e6 9781      		ldd r25,Z+7
 686 00e8 9383      		std Z+3,r25
 180:aes.c         ****   (*state)[2][3] = (*state)[3][3];
 687               		.loc 1 180 0
 688 00ea 9385      		ldd r25,Z+11
 689 00ec 9783      		std Z+7,r25
 181:aes.c         ****   (*state)[3][3] = temp;
 690               		.loc 1 181 0
 691 00ee 9785      		ldd r25,Z+15
 692 00f0 9387      		std Z+11,r25
 182:aes.c         **** }
 693               		.loc 1 182 0
 694 00f2 8787      		std Z+15,r24
 695               	.LVL64:
 696               	.LBE19:
 697               	.LBE18:
 198:aes.c         ****     AddRoundKey(round, state, RoundKey);
 698               		.loc 1 198 0
 699 00f4 C801      		movw r24,r16
 700 00f6 0E94 0000 		call InvSubBytes
 701               	.LVL65:
 199:aes.c         ****     InvMixColumns(state);
 702               		.loc 1 199 0
 703 00fa A301      		movw r20,r6
 704 00fc B801      		movw r22,r16
 705 00fe 8989      		ldd r24,Y+17
 706 0100 0E94 0000 		call AddRoundKey
 707               	.LVL66:
 708 0104 2801      		movw r4,r16
 709               	.LVL67:
 710               	.L20:
 711               	.LBB20:
 712               	.LBB21:
 130:aes.c         ****     b = (*state)[i][1];
 713               		.loc 1 130 0
 714 0106 F201      		movw r30,r4
 715 0108 3080      		ld r3,Z
 716               	.LVL68:
 131:aes.c         ****     c = (*state)[i][2];
 717               		.loc 1 131 0
 718 010a D180      		ldd r13,Z+1
 719               	.LVL69:
 132:aes.c         ****     d = (*state)[i][3];
 720               		.loc 1 132 0
 721 010c E280      		ldd r14,Z+2
 722               	.LVL70:
 133:aes.c         **** 
 723               		.loc 1 133 0
 724 010e F381      		ldd r31,Z+3
 725 0110 FA8B      		std Y+18,r31
 726               	.LVL71:
 135:aes.c         ****     (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
 727               		.loc 1 135 0
 728 0112 832D      		mov r24,r3
 729 0114 0E94 0000 		call xtime
 730               	.LVL72:
 731 0118 F82E      		mov r15,r24
 732 011a 0E94 0000 		call xtime
 733               	.LVL73:
 734 011e 8D8B      		std Y+21,r24
 735 0120 0E94 0000 		call xtime
 736               	.LVL74:
 737 0124 B82E      		mov r11,r24
 738 0126 8D2D      		mov r24,r13
 739 0128 0E94 0000 		call xtime
 740               	.LVL75:
 741 012c 8E8B      		std Y+22,r24
 742 012e 0E94 0000 		call xtime
 743               	.LVL76:
 744 0132 882E      		mov r8,r24
 745 0134 0E94 0000 		call xtime
 746               	.LVL77:
 747 0138 C82E      		mov r12,r24
 748 013a 8E2D      		mov r24,r14
 749 013c 0E94 0000 		call xtime
 750               	.LVL78:
 751 0140 8F8B      		std Y+23,r24
 752 0142 0E94 0000 		call xtime
 753               	.LVL79:
 754 0146 888F      		std Y+24,r24
 755 0148 0E94 0000 		call xtime
 756               	.LVL80:
 757 014c 282E      		mov r2,r24
 758 014e 8A89      		ldd r24,Y+18
 759 0150 0E94 0000 		call xtime
 760               	.LVL81:
 761 0154 982E      		mov r9,r24
 762 0156 0E94 0000 		call xtime
 763               	.LVL82:
 764 015a A82E      		mov r10,r24
 765 015c 0E94 0000 		call xtime
 766               	.LVL83:
 767 0160 9D89      		ldd r25,Y+21
 768 0162 9F25      		eor r25,r15
 769 0164 9B25      		eor r25,r11
 770 0166 2E89      		ldd r18,Y+22
 771 0168 9227      		eor r25,r18
 772 016a 9C25      		eor r25,r12
 773 016c 388D      		ldd r19,Y+24
 774 016e 9327      		eor r25,r19
 775 0170 9225      		eor r25,r2
 776 0172 9827      		eor r25,r24
 777 0174 9D25      		eor r25,r13
 778 0176 9E25      		eor r25,r14
 779 0178 4A89      		ldd r20,Y+18
 780 017a 9427      		eor r25,r20
 781 017c F201      		movw r30,r4
 782 017e 9083      		st Z,r25
 136:aes.c         ****     (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
 783               		.loc 1 136 0
 784 0180 922F      		mov r25,r18
 785 0182 9B25      		eor r25,r11
 786 0184 9825      		eor r25,r8
 787 0186 9C25      		eor r25,r12
 788 0188 FF89      		ldd r31,Y+23
 789 018a 9F27      		eor r25,r31
 790 018c 9225      		eor r25,r2
 791 018e 9A25      		eor r25,r10
 792 0190 9827      		eor r25,r24
 793 0192 9325      		eor r25,r3
 794 0194 9E25      		eor r25,r14
 795 0196 9427      		eor r25,r20
 796 0198 F201      		movw r30,r4
 797 019a 9183      		std Z+1,r25
 137:aes.c         ****     (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
 798               		.loc 1 137 0
 799 019c 9D89      		ldd r25,Y+21
 800 019e 9B25      		eor r25,r11
 801 01a0 9C25      		eor r25,r12
 802 01a2 FF89      		ldd r31,Y+23
 803 01a4 9F27      		eor r25,r31
 804 01a6 9327      		eor r25,r19
 805 01a8 9225      		eor r25,r2
 806 01aa 9925      		eor r25,r9
 807 01ac 9827      		eor r25,r24
 808 01ae 9325      		eor r25,r3
 809 01b0 9D25      		eor r25,r13
 810 01b2 9427      		eor r25,r20
 811 01b4 F201      		movw r30,r4
 812 01b6 9283      		std Z+2,r25
 138:aes.c         ****   }
 813               		.loc 1 138 0
 814 01b8 FB24      		eor r15,r11
 815 01ba 8F24      		eor r8,r15
 816 01bc C824      		eor r12,r8
 817 01be C224      		eor r12,r2
 818 01c0 9C24      		eor r9,r12
 819 01c2 A924      		eor r10,r9
 820 01c4 A826      		eor r10,r24
 821 01c6 A324      		eor r10,r3
 822 01c8 AD24      		eor r10,r13
 823 01ca AE24      		eor r10,r14
 824 01cc A382      		std Z+3,r10
 825 01ce F4E0      		ldi r31,4
 826 01d0 4F0E      		add r4,r31
 827 01d2 511C      		adc r5,__zero_reg__
 128:aes.c         ****   { 
 828               		.loc 1 128 0
 829 01d4 298D      		ldd r18,Y+25
 830 01d6 3A8D      		ldd r19,Y+26
 831 01d8 2415      		cp r18,r4
 832 01da 3505      		cpc r19,r5
 833 01dc 01F0      		breq .+2
 834 01de 00C0      		rjmp .L20
 835               	.LVL84:
 836               	.LBE21:
 837               	.LBE20:
 195:aes.c         ****   {
 838               		.loc 1 195 0
 839 01e0 3989      		ldd r19,Y+17
 840 01e2 3150      		subi r19,lo8(-(-1))
 841 01e4 398B      		std Y+17,r19
 842               	.LVL85:
 843 01e6 3111      		cpse r19,__zero_reg__
 844 01e8 00C0      		rjmp .L21
 845               	.LVL86:
 846               	.LBB22:
 847               	.LBB23:
 162:aes.c         ****   (*state)[3][1] = (*state)[2][1];
 848               		.loc 1 162 0
 849 01ea F801      		movw r30,r16
 850 01ec 8585      		ldd r24,Z+13
 851               	.LVL87:
 163:aes.c         ****   (*state)[2][1] = (*state)[1][1];
 852               		.loc 1 163 0
 853 01ee 9185      		ldd r25,Z+9
 854 01f0 9587      		std Z+13,r25
 164:aes.c         ****   (*state)[1][1] = (*state)[0][1];
 855               		.loc 1 164 0
 856 01f2 9581      		ldd r25,Z+5
 857 01f4 9187      		std Z+9,r25
 165:aes.c         ****   (*state)[0][1] = temp;
 858               		.loc 1 165 0
 859 01f6 9181      		ldd r25,Z+1
 860 01f8 9583      		std Z+5,r25
 166:aes.c         **** 
 861               		.loc 1 166 0
 862 01fa 8183      		std Z+1,r24
 169:aes.c         ****   (*state)[0][2] = (*state)[2][2];
 863               		.loc 1 169 0
 864 01fc 8281      		ldd r24,Z+2
 865               	.LVL88:
 170:aes.c         ****   (*state)[2][2] = temp;
 866               		.loc 1 170 0
 867 01fe 9285      		ldd r25,Z+10
 868 0200 9283      		std Z+2,r25
 171:aes.c         **** 
 869               		.loc 1 171 0
 870 0202 8287      		std Z+10,r24
 173:aes.c         ****   (*state)[1][2] = (*state)[3][2];
 871               		.loc 1 173 0
 872 0204 8681      		ldd r24,Z+6
 873               	.LVL89:
 174:aes.c         ****   (*state)[3][2] = temp;
 874               		.loc 1 174 0
 875 0206 9685      		ldd r25,Z+14
 876 0208 9683      		std Z+6,r25
 175:aes.c         **** 
 877               		.loc 1 175 0
 878 020a 8687      		std Z+14,r24
 178:aes.c         ****   (*state)[0][3] = (*state)[1][3];
 879               		.loc 1 178 0
 880 020c 8381      		ldd r24,Z+3
 881               	.LVL90:
 179:aes.c         ****   (*state)[1][3] = (*state)[2][3];
 882               		.loc 1 179 0
 883 020e 9781      		ldd r25,Z+7
 884 0210 9383      		std Z+3,r25
 180:aes.c         ****   (*state)[2][3] = (*state)[3][3];
 885               		.loc 1 180 0
 886 0212 9385      		ldd r25,Z+11
 887 0214 9783      		std Z+7,r25
 181:aes.c         ****   (*state)[3][3] = temp;
 888               		.loc 1 181 0
 889 0216 9785      		ldd r25,Z+15
 890 0218 9387      		std Z+11,r25
 182:aes.c         **** }
 891               		.loc 1 182 0
 892 021a 8787      		std Z+15,r24
 893               	.LVL91:
 894               	.LBE23:
 895               	.LBE22:
 206:aes.c         ****   AddRoundKey(0, state, RoundKey);
 896               		.loc 1 206 0
 897 021c C801      		movw r24,r16
 898 021e 0E94 0000 		call InvSubBytes
 899               	.LVL92:
 207:aes.c         **** }
 900               		.loc 1 207 0
 901 0222 A301      		movw r20,r6
 902 0224 B801      		movw r22,r16
 903 0226 80E0      		ldi r24,0
 904 0228 0E94 0000 		call AddRoundKey
 905               	.LVL93:
 906               	.LBE17:
 907               	.LBE16:
 228:aes.c         ****     memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
 908               		.loc 1 228 0
 909 022c A301      		movw r20,r6
 910 022e 4055      		subi r20,80
 911 0230 5F4F      		sbci r21,-1
 912               	.LVL94:
 913 0232 DA01      		movw r26,r20
 914               	.LVL95:
 915               	.L22:
 916               	.LBB24:
 917               	.LBB25:
 216:aes.c         ****   }
 918               		.loc 1 216 0
 919 0234 EB89      		ldd r30,Y+19
 920 0236 FC89      		ldd r31,Y+20
 921 0238 8191      		ld r24,Z+
 922 023a FC8B      		std Y+20,r31
 923 023c EB8B      		std Y+19,r30
 924               	.LVL96:
 925 023e FA01      		movw r30,r20
 926 0240 9191      		ld r25,Z+
 927 0242 AF01      		movw r20,r30
 928 0244 2B89      		ldd r18,Y+19
 929 0246 3C89      		ldd r19,Y+20
 930 0248 2150      		subi r18,1
 931 024a 3109      		sbc r19,__zero_reg__
 932 024c 8927      		eor r24,r25
 933 024e F901      		movw r30,r18
 934 0250 8083      		st Z,r24
 935               	.LVL97:
 214:aes.c         ****   {
 936               		.loc 1 214 0
 937 0252 2B89      		ldd r18,Y+19
 938 0254 3C89      		ldd r19,Y+20
 939 0256 4216      		cp r4,r18
 940 0258 5306      		cpc r5,r19
 941 025a 01F4      		brne .L22
 942               	.LVL98:
 943               	.LBE25:
 944               	.LBE24:
 229:aes.c         ****     buf += AES_BLOCKLEN;
 945               		.loc 1 229 0 discriminator 3
 946 025c 80E1      		ldi r24,lo8(16)
 947 025e FE01      		movw r30,r28
 948 0260 3196      		adiw r30,1
 949               		0:
 950 0262 0190      		ld r0,Z+
 951 0264 0D92      		st X+,r0
 952 0266 8A95      		dec r24
 953 0268 01F4      		brne 0b
 230:aes.c         ****   }
 954               		.loc 1 230 0 discriminator 3
 955 026a 005F      		subi r16,-16
 956 026c 1F4F      		sbci r17,-1
 957               	.LVL99:
 958 026e 498D      		ldd r20,Y+25
 959 0270 5A8D      		ldd r21,Y+26
 960 0272 405F      		subi r20,-16
 961 0274 5F4F      		sbci r21,-1
 962 0276 5A8F      		std Y+26,r21
 963 0278 498F      		std Y+25,r20
 964 027a 00C0      		rjmp .L19
 965               		.cfi_endproc
 966               	.LFE12:
 968               	.global	iv
 969               		.data
 972               	iv:
 973 0000 00        		.byte	0
 974 0001 01        		.byte	1
 975 0002 02        		.byte	2
 976 0003 03        		.byte	3
 977 0004 04        		.byte	4
 978 0005 05        		.byte	5
 979 0006 06        		.byte	6
 980 0007 07        		.byte	7
 981 0008 08        		.byte	8
 982 0009 09        		.byte	9
 983 000a 0A        		.byte	10
 984 000b 0B        		.byte	11
 985 000c 0C        		.byte	12
 986 000d 0D        		.byte	13
 987 000e 0E        		.byte	14
 988 000f 0F        		.byte	15
 989               	.global	key
 992               	key:
 993 0010 00        		.byte	0
 994 0011 01        		.byte	1
 995 0012 02        		.byte	2
 996 0013 03        		.byte	3
 997 0014 04        		.byte	4
 998 0015 05        		.byte	5
 999 0016 06        		.byte	6
 1000 0017 07        		.byte	7
 1001 0018 08        		.byte	8
 1002 0019 09        		.byte	9
 1003 001a 0A        		.byte	10
 1004 001b 0B        		.byte	11
 1005 001c 0C        		.byte	12
 1006 001d 0D        		.byte	13
 1007 001e 0E        		.byte	14
 1008 001f 0F        		.byte	15
 1009               		.comm	ctx,192,1
 1010               		.section	.rodata
 1013               	Rcon:
 1014 0000 8D        		.byte	-115
 1015 0001 01        		.byte	1
 1016 0002 02        		.byte	2
 1017 0003 04        		.byte	4
 1018 0004 08        		.byte	8
 1019 0005 10        		.byte	16
 1020 0006 20        		.byte	32
 1021 0007 40        		.byte	64
 1022 0008 80        		.byte	-128
 1023 0009 1B        		.byte	27
 1024 000a 36        		.byte	54
 1025               		.text
 1026               	.Letext0:
 1027               		.file 2 "/usr/avr/include/stdint.h"
 1028               		.file 3 "aes.h"
 1029               		.file 4 "spi_flash.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 aes.c
     /tmp/cckFfdMw.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cckFfdMw.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cckFfdMw.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cckFfdMw.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cckFfdMw.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cckFfdMw.s:12     .text.AddRoundKey:0000000000000000 AddRoundKey
     /tmp/cckFfdMw.s:87     .text.xtime:0000000000000000 xtime
     /tmp/cckFfdMw.s:116    .text.InvSubBytes:0000000000000000 InvSubBytes
     /tmp/cckFfdMw.s:205    .text.AES_init_ctx_iv:0000000000000000 AES_init_ctx_iv
     /tmp/cckFfdMw.s:1013   .rodata:0000000000000000 Rcon
     /tmp/cckFfdMw.s:459    .text.AES_CBC_decrypt_buffer:0000000000000000 AES_CBC_decrypt_buffer
     /tmp/cckFfdMw.s:972    .data:0000000000000000 iv
     /tmp/cckFfdMw.s:992    .data:0000000000000010 key
                            *COM*:00000000000000c0 ctx

UNDEFINED SYMBOLS
FLASH_readByte
__do_copy_data
__do_clear_bss
