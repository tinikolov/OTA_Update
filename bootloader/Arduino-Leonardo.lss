
Arduino-Leonardo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  00007826  000008ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000826  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ed  0080012c  0080012c  000008e6  2**0
                  ALLOC
  3 .stab         00000204  00000000  00000000  000008e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000009c  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000021  00000000  00000000  00000b88  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000bac  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 000000d8  00000000  00000000  00000bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000196f  00000000  00000000  00000cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000eef  00000000  00000000  00002633  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000081d  00000000  00000000  00003522  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000002ac  00000000  00000000  00003d40  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000712  00000000  00000000  00003fec  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00000c52  00000000  00000000  000046fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000100  00000000  00000000  00005350  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	55 c0       	rjmp	.+170    	; 0x70ac <__ctors_end>
    7002:	00 00       	nop
    7004:	6e c0       	rjmp	.+220    	; 0x70e2 <__bad_interrupt>
    7006:	00 00       	nop
    7008:	6c c0       	rjmp	.+216    	; 0x70e2 <__bad_interrupt>
    700a:	00 00       	nop
    700c:	6a c0       	rjmp	.+212    	; 0x70e2 <__bad_interrupt>
    700e:	00 00       	nop
    7010:	68 c0       	rjmp	.+208    	; 0x70e2 <__bad_interrupt>
    7012:	00 00       	nop
    7014:	66 c0       	rjmp	.+204    	; 0x70e2 <__bad_interrupt>
    7016:	00 00       	nop
    7018:	64 c0       	rjmp	.+200    	; 0x70e2 <__bad_interrupt>
    701a:	00 00       	nop
    701c:	62 c0       	rjmp	.+196    	; 0x70e2 <__bad_interrupt>
    701e:	00 00       	nop
    7020:	60 c0       	rjmp	.+192    	; 0x70e2 <__bad_interrupt>
    7022:	00 00       	nop
    7024:	5e c0       	rjmp	.+188    	; 0x70e2 <__bad_interrupt>
    7026:	00 00       	nop
    7028:	5c c0       	rjmp	.+184    	; 0x70e2 <__bad_interrupt>
    702a:	00 00       	nop
    702c:	5a c0       	rjmp	.+180    	; 0x70e2 <__bad_interrupt>
    702e:	00 00       	nop
    7030:	58 c0       	rjmp	.+176    	; 0x70e2 <__bad_interrupt>
    7032:	00 00       	nop
    7034:	56 c0       	rjmp	.+172    	; 0x70e2 <__bad_interrupt>
    7036:	00 00       	nop
    7038:	54 c0       	rjmp	.+168    	; 0x70e2 <__bad_interrupt>
    703a:	00 00       	nop
    703c:	52 c0       	rjmp	.+164    	; 0x70e2 <__bad_interrupt>
    703e:	00 00       	nop
    7040:	50 c0       	rjmp	.+160    	; 0x70e2 <__bad_interrupt>
    7042:	00 00       	nop
    7044:	4e c0       	rjmp	.+156    	; 0x70e2 <__bad_interrupt>
    7046:	00 00       	nop
    7048:	4c c0       	rjmp	.+152    	; 0x70e2 <__bad_interrupt>
    704a:	00 00       	nop
    704c:	4a c0       	rjmp	.+148    	; 0x70e2 <__bad_interrupt>
    704e:	00 00       	nop
    7050:	48 c0       	rjmp	.+144    	; 0x70e2 <__bad_interrupt>
    7052:	00 00       	nop
    7054:	46 c0       	rjmp	.+140    	; 0x70e2 <__bad_interrupt>
    7056:	00 00       	nop
    7058:	44 c0       	rjmp	.+136    	; 0x70e2 <__bad_interrupt>
    705a:	00 00       	nop
    705c:	42 c0       	rjmp	.+132    	; 0x70e2 <__bad_interrupt>
    705e:	00 00       	nop
    7060:	40 c0       	rjmp	.+128    	; 0x70e2 <__bad_interrupt>
    7062:	00 00       	nop
    7064:	3e c0       	rjmp	.+124    	; 0x70e2 <__bad_interrupt>
    7066:	00 00       	nop
    7068:	3c c0       	rjmp	.+120    	; 0x70e2 <__bad_interrupt>
    706a:	00 00       	nop
    706c:	3a c0       	rjmp	.+116    	; 0x70e2 <__bad_interrupt>
    706e:	00 00       	nop
    7070:	38 c0       	rjmp	.+112    	; 0x70e2 <__bad_interrupt>
    7072:	00 00       	nop
    7074:	36 c0       	rjmp	.+108    	; 0x70e2 <__bad_interrupt>
    7076:	00 00       	nop
    7078:	34 c0       	rjmp	.+104    	; 0x70e2 <__bad_interrupt>
    707a:	00 00       	nop
    707c:	32 c0       	rjmp	.+100    	; 0x70e2 <__bad_interrupt>
    707e:	00 00       	nop
    7080:	30 c0       	rjmp	.+96     	; 0x70e2 <__bad_interrupt>
    7082:	00 00       	nop
    7084:	2e c0       	rjmp	.+92     	; 0x70e2 <__bad_interrupt>
    7086:	00 00       	nop
    7088:	2c c0       	rjmp	.+88     	; 0x70e2 <__bad_interrupt>
    708a:	00 00       	nop
    708c:	2a c0       	rjmp	.+84     	; 0x70e2 <__bad_interrupt>
    708e:	00 00       	nop
    7090:	28 c0       	rjmp	.+80     	; 0x70e2 <__bad_interrupt>
    7092:	00 00       	nop
    7094:	26 c0       	rjmp	.+76     	; 0x70e2 <__bad_interrupt>
    7096:	00 00       	nop
    7098:	24 c0       	rjmp	.+72     	; 0x70e2 <__bad_interrupt>
    709a:	00 00       	nop
    709c:	22 c0       	rjmp	.+68     	; 0x70e2 <__bad_interrupt>
    709e:	00 00       	nop
    70a0:	20 c0       	rjmp	.+64     	; 0x70e2 <__bad_interrupt>
    70a2:	00 00       	nop
    70a4:	1e c0       	rjmp	.+60     	; 0x70e2 <__bad_interrupt>
    70a6:	00 00       	nop
    70a8:	1c c0       	rjmp	.+56     	; 0x70e2 <__bad_interrupt>
    70aa:	00 00       	nop

000070ac <__ctors_end>:
    70ac:	11 24       	eor	r1, r1
    70ae:	1f be       	out	0x3f, r1	; 63
    70b0:	cf ef       	ldi	r28, 0xFF	; 255
    70b2:	da e0       	ldi	r29, 0x0A	; 10
    70b4:	de bf       	out	0x3e, r29	; 62
    70b6:	cd bf       	out	0x3d, r28	; 61

000070b8 <__do_copy_data>:
    70b8:	11 e0       	ldi	r17, 0x01	; 1
    70ba:	a0 e0       	ldi	r26, 0x00	; 0
    70bc:	b1 e0       	ldi	r27, 0x01	; 1
    70be:	e6 e2       	ldi	r30, 0x26	; 38
    70c0:	f8 e7       	ldi	r31, 0x78	; 120
    70c2:	02 c0       	rjmp	.+4      	; 0x70c8 <__do_copy_data+0x10>
    70c4:	05 90       	lpm	r0, Z+
    70c6:	0d 92       	st	X+, r0
    70c8:	ac 32       	cpi	r26, 0x2C	; 44
    70ca:	b1 07       	cpc	r27, r17
    70cc:	d9 f7       	brne	.-10     	; 0x70c4 <__do_copy_data+0xc>

000070ce <__do_clear_bss>:
    70ce:	22 e0       	ldi	r18, 0x02	; 2
    70d0:	ac e2       	ldi	r26, 0x2C	; 44
    70d2:	b1 e0       	ldi	r27, 0x01	; 1
    70d4:	01 c0       	rjmp	.+2      	; 0x70d8 <.do_clear_bss_start>

000070d6 <.do_clear_bss_loop>:
    70d6:	1d 92       	st	X+, r1

000070d8 <.do_clear_bss_start>:
    70d8:	a9 31       	cpi	r26, 0x19	; 25
    70da:	b2 07       	cpc	r27, r18
    70dc:	e1 f7       	brne	.-8      	; 0x70d6 <.do_clear_bss_loop>
    70de:	7b d3       	rcall	.+1782   	; 0x77d6 <main>
    70e0:	a0 c3       	rjmp	.+1856   	; 0x7822 <_exit>

000070e2 <__bad_interrupt>:
    70e2:	8e cf       	rjmp	.-228    	; 0x7000 <__vectors>

000070e4 <SPI_transfer>:

    return true;
}

uint8_t SPI_transfer(uint8_t data) {
    SPDR = data;
    70e4:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
     __asm__ __volatile__("nop");
    70e6:	00 00       	nop
    while (!(SPSR & _BV(SPIF))) ; // wait
    70e8:	0d b4       	in	r0, 0x2d	; 45
    70ea:	07 fe       	sbrs	r0, 7
    70ec:	fd cf       	rjmp	.-6      	; 0x70e8 <SPI_transfer+0x4>
    return SPDR;
    70ee:	8e b5       	in	r24, 0x2e	; 46
  }
    70f0:	08 95       	ret

000070f2 <FLASH_busy>:


uint8_t FLASH_busy(void) {

  FLASH_SELECT;
    70f2:	47 98       	cbi	0x08, 7	; 8
  SPI_transfer(SPIFLASH_STATUSREAD);
    70f4:	85 e0       	ldi	r24, 0x05	; 5
  uint8_t status = SPI_transfer(0);
    70f6:	f6 df       	rcall	.-20     	; 0x70e4 <SPI_transfer>
    70f8:	80 e0       	ldi	r24, 0x00	; 0
  FLASH_UNSELECT;
    70fa:	f4 df       	rcall	.-24     	; 0x70e4 <SPI_transfer>

  return status & 1;
}
    70fc:	47 9a       	sbi	0x08, 7	; 8
    70fe:	81 70       	andi	r24, 0x01	; 1
    7100:	08 95       	ret

00007102 <readDeviceId>:

/* Return device unique ID. Used to verify the connection with the FLASH during initiliaziation */
uint16_t readDeviceId(void)
{
    7102:	cf 93       	push	r28
    7104:	df 93       	push	r29
  FLASH_SELECT
    7106:	47 98       	cbi	0x08, 7	; 8
  SPI_transfer(SPIFLASH_JEDECID);
    7108:	8f e9       	ldi	r24, 0x9F	; 159
  uint16_t jedecid = SPI_transfer(0) << 8;
    710a:	ec df       	rcall	.-40     	; 0x70e4 <SPI_transfer>
    710c:	80 e0       	ldi	r24, 0x00	; 0
    710e:	ea df       	rcall	.-44     	; 0x70e4 <SPI_transfer>
    7110:	c8 2f       	mov	r28, r24
    7112:	d0 e0       	ldi	r29, 0x00	; 0
  jedecid |= SPI_transfer(0);
    7114:	dc 2f       	mov	r29, r28
    7116:	cc 27       	eor	r28, r28
    7118:	80 e0       	ldi	r24, 0x00	; 0
  FLASH_UNSELECT
    711a:	e4 df       	rcall	.-56     	; 0x70e4 <SPI_transfer>
  return jedecid;
}
    711c:	47 9a       	sbi	0x08, 7	; 8
    711e:	9e 01       	movw	r18, r28
    7120:	28 2b       	or	r18, r24
    7122:	c9 01       	movw	r24, r18
    7124:	df 91       	pop	r29
    7126:	cf 91       	pop	r28
    7128:	08 95       	ret

0000712a <SPI_init>:
    SPI_DDR |= _BV(SPI_SS_PIN) | _BV(SPI_MOSI_PIN) | _BV(SPI_CLK_PIN); // OUTPUTS for SS, MOSI, SCK
    712a:	84 b1       	in	r24, 0x04	; 4
    712c:	87 60       	ori	r24, 0x07	; 7
    712e:	84 b9       	out	0x04, r24	; 4
    FLASHSS_DDR |= _BV(SPI_SS_PIN);
    7130:	40 9a       	sbi	0x08, 0	; 8
    SPI_PORT |= _BV(SPI_SS_PIN); //PB2 output: High (deselect other SPI chips) 
    7132:	28 9a       	sbi	0x05, 0	; 5
    SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); //enable SPI and set SPI to MASTER mode
    7134:	81 e5       	ldi	r24, 0x51	; 81
    uint16_t deviceId = readDeviceId();
    7136:	8c bd       	out	0x2c, r24	; 44
    7138:	e4 df       	rcall	.-56     	; 0x7102 <readDeviceId>
    if (deviceId==0 || deviceId==0xFF) return false;
    713a:	9c 01       	movw	r18, r24
    713c:	89 2b       	or	r24, r25
    713e:	21 f0       	breq	.+8      	; 0x7148 <SPI_init+0x1e>
    7140:	81 e0       	ldi	r24, 0x01	; 1
    7142:	2f 3f       	cpi	r18, 0xFF	; 255
    7144:	31 05       	cpc	r19, r1
    7146:	09 f4       	brne	.+2      	; 0x714a <SPI_init+0x20>
}
    7148:	80 e0       	ldi	r24, 0x00	; 0
    714a:	08 95       	ret

0000714c <Flash_readByteArray>:
/* Read array of bytes 
 *  1. *buf - array where the data will be stored
 *  2. addr - starting address 
 *  3. len - number of bytes to read 
 */
void Flash_readByteArray(void *buf, uint32_t addr, uint8_t len){
    714c:	ef 92       	push	r14
    714e:	ff 92       	push	r15
    7150:	0f 93       	push	r16
    7152:	1f 93       	push	r17
    7154:	cf 93       	push	r28
    7156:	df 93       	push	r29
    7158:	f8 2e       	mov	r15, r24
    715a:	19 2f       	mov	r17, r25
    715c:	ea 01       	movw	r28, r20
    715e:	e6 2e       	mov	r14, r22

    while(FLASH_busy());
    7160:	02 2f       	mov	r16, r18
    7162:	c7 df       	rcall	.-114    	; 0x70f2 <FLASH_busy>
    7164:	81 11       	cpse	r24, r1
    FLASH_SELECT
    SPI_transfer(SPIFLASH_ARRAYREAD);
    7166:	fd cf       	rjmp	.-6      	; 0x7162 <Flash_readByteArray+0x16>
    SPI_transfer(addr >> 16);
    7168:	47 98       	cbi	0x08, 7	; 8
    SPI_transfer(addr >> 8);
    716a:	8b e0       	ldi	r24, 0x0B	; 11
    SPI_transfer(addr);
    716c:	bb df       	rcall	.-138    	; 0x70e4 <SPI_transfer>
    716e:	8e 2d       	mov	r24, r14
    7170:	b9 df       	rcall	.-142    	; 0x70e4 <SPI_transfer>
    SPI_transfer(0); //"dont care"
    7172:	8d 2f       	mov	r24, r29
    7174:	b7 df       	rcall	.-146    	; 0x70e4 <SPI_transfer>
    7176:	8c 2f       	mov	r24, r28
    7178:	b5 df       	rcall	.-150    	; 0x70e4 <SPI_transfer>
    717a:	80 e0       	ldi	r24, 0x00	; 0
    717c:	b3 df       	rcall	.-154    	; 0x70e4 <SPI_transfer>
    717e:	cf 2d       	mov	r28, r15
    7180:	d1 2f       	mov	r29, r17
    
    for (uint8_t i = 0; i < len; ++i)
    7182:	0c 0f       	add	r16, r28
    7184:	1d 2f       	mov	r17, r29
    7186:	11 1d       	adc	r17, r1
      ((uint8_t*) buf)[i] = SPI_transfer(0);
    FLASH_UNSELECT
    7188:	c0 17       	cp	r28, r16
}
    718a:	d1 07       	cpc	r29, r17
    718c:	41 f4       	brne	.+16     	; 0x719e <Flash_readByteArray+0x52>
    718e:	47 9a       	sbi	0x08, 7	; 8
    7190:	df 91       	pop	r29
    7192:	cf 91       	pop	r28
    7194:	1f 91       	pop	r17
      ((uint8_t*) buf)[i] = SPI_transfer(0);
    7196:	0f 91       	pop	r16
    7198:	ff 90       	pop	r15
    719a:	ef 90       	pop	r14
    719c:	08 95       	ret
    719e:	80 e0       	ldi	r24, 0x00	; 0
    71a0:	a1 df       	rcall	.-190    	; 0x70e4 <SPI_transfer>
    71a2:	89 93       	st	Y+, r24
    71a4:	f1 cf       	rjmp	.-30     	; 0x7188 <Flash_readByteArray+0x3c>

000071a6 <FLASH_readByte>:

/* Read one byte from SPI flash with giving the address.
 *  Function return the read data from this address 
 */
uint8_t FLASH_readByte(uint32_t addr) {
    71a6:	1f 93       	push	r17
    71a8:	cf 93       	push	r28
    71aa:	df 93       	push	r29
    71ac:	eb 01       	movw	r28, r22

  while(FLASH_busy());
    71ae:	18 2f       	mov	r17, r24
    71b0:	a0 df       	rcall	.-192    	; 0x70f2 <FLASH_busy>
    71b2:	81 11       	cpse	r24, r1
  FLASH_SELECT
  SPI_transfer(SPIFLASH_READ_DATA);
    71b4:	fd cf       	rjmp	.-6      	; 0x71b0 <FLASH_readByte+0xa>
  SPI_transfer((addr >> 16) & 0xFF);
    71b6:	47 98       	cbi	0x08, 7	; 8
  SPI_transfer((addr >> 8) & 0xFF);
    71b8:	83 e0       	ldi	r24, 0x03	; 3
  SPI_transfer(addr & 0xFF);
    71ba:	94 df       	rcall	.-216    	; 0x70e4 <SPI_transfer>
    71bc:	81 2f       	mov	r24, r17
    71be:	92 df       	rcall	.-220    	; 0x70e4 <SPI_transfer>

  uint8_t result = SPI_transfer(0);
    71c0:	8d 2f       	mov	r24, r29
    71c2:	90 df       	rcall	.-224    	; 0x70e4 <SPI_transfer>
    71c4:	8c 2f       	mov	r24, r28
  FLASH_UNSELECT
    71c6:	8e df       	rcall	.-228    	; 0x70e4 <SPI_transfer>

  return result;
}
    71c8:	80 e0       	ldi	r24, 0x00	; 0
    71ca:	8c df       	rcall	.-232    	; 0x70e4 <SPI_transfer>
    71cc:	47 9a       	sbi	0x08, 7	; 8
    71ce:	df 91       	pop	r29
    71d0:	cf 91       	pop	r28
    71d2:	1f 91       	pop	r17
    71d4:	08 95       	ret

000071d6 <AddRoundKey>:


// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
    71d6:	1f 93       	push	r17
    71d8:	cf 93       	push	r28
    71da:	df 93       	push	r29
    71dc:	20 e1       	ldi	r18, 0x10	; 16
    71de:	82 9f       	mul	r24, r18
    71e0:	c0 01       	movw	r24, r0
    71e2:	11 24       	eor	r1, r1
    71e4:	48 0f       	add	r20, r24
    71e6:	59 1f       	adc	r21, r25
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    71e8:	30 e0       	ldi	r19, 0x00	; 0
    71ea:	20 e0       	ldi	r18, 0x00	; 0
    71ec:	fb 01       	movw	r30, r22
    71ee:	e2 0f       	add	r30, r18
    71f0:	f3 1f       	adc	r31, r19
    71f2:	d9 01       	movw	r26, r18
    71f4:	a4 0f       	add	r26, r20
    71f6:	b5 1f       	adc	r27, r21
    for (j = 0; j < 4; ++j)
    71f8:	90 e0       	ldi	r25, 0x00	; 0
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    71fa:	81 91       	ld	r24, Z+
    71fc:	1d 91       	ld	r17, X+
    71fe:	ef 01       	movw	r28, r30
    7200:	21 97       	sbiw	r28, 0x01	; 1
    7202:	81 27       	eor	r24, r17
    7204:	88 83       	st	Y, r24
    for (j = 0; j < 4; ++j)
    7206:	9f 5f       	subi	r25, 0xFF	; 255
    7208:	94 30       	cpi	r25, 0x04	; 4
    720a:	b9 f7       	brne	.-18     	; 0x71fa <AddRoundKey+0x24>
    720c:	2c 5f       	subi	r18, 0xFC	; 252
    720e:	3f 4f       	sbci	r19, 0xFF	; 255
  for (i = 0; i < 4; ++i)
    7210:	20 31       	cpi	r18, 0x10	; 16
    7212:	31 05       	cpc	r19, r1
    7214:	59 f7       	brne	.-42     	; 0x71ec <AddRoundKey+0x16>
    }
  }
}
    7216:	df 91       	pop	r29
    7218:	cf 91       	pop	r28
    721a:	1f 91       	pop	r17
    721c:	08 95       	ret

0000721e <xtime>:

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
    721e:	98 2f       	mov	r25, r24
    7220:	99 1f       	adc	r25, r25
    7222:	99 27       	eor	r25, r25
    7224:	99 1f       	adc	r25, r25
    7226:	2b e1       	ldi	r18, 0x1B	; 27
    7228:	92 9f       	mul	r25, r18
    722a:	90 2d       	mov	r25, r0
    722c:	11 24       	eor	r1, r1
    722e:	88 0f       	add	r24, r24
}
    7230:	89 27       	eor	r24, r25
    7232:	08 95       	ret

00007234 <InvSubBytes>:


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
    7234:	ef 92       	push	r14
    7236:	ff 92       	push	r15
    7238:	0f 93       	push	r16
    723a:	1f 93       	push	r17
    723c:	cf 93       	push	r28
    723e:	df 93       	push	r29
    7240:	8c 01       	movw	r16, r24
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    7242:	84 e0       	ldi	r24, 0x04	; 4
    7244:	e8 2e       	mov	r14, r24
{
    7246:	e8 01       	movw	r28, r16
    for (j = 0; j < 4; ++j)
    7248:	f1 2c       	mov	r15, r1
    {
      (*state)[j][i] = FLASH_readByte(SECTOR_RSBOX_VALUE + (*state)[j][i]); //getSBoxInvert((*state)[j][i]);
    724a:	68 81       	ld	r22, Y
    724c:	70 e0       	ldi	r23, 0x00	; 0
    724e:	7f 5e       	subi	r23, 0xEF	; 239
    7250:	07 2e       	mov	r0, r23
    7252:	00 0c       	add	r0, r0
    7254:	88 0b       	sbc	r24, r24
    7256:	99 0b       	sbc	r25, r25
    7258:	a6 df       	rcall	.-180    	; 0x71a6 <FLASH_readByte>
    725a:	88 83       	st	Y, r24
    for (j = 0; j < 4; ++j)
    725c:	f3 94       	inc	r15
    725e:	24 96       	adiw	r28, 0x04	; 4
    7260:	84 e0       	ldi	r24, 0x04	; 4
    7262:	f8 12       	cpse	r15, r24
    7264:	f2 cf       	rjmp	.-28     	; 0x724a <InvSubBytes+0x16>
    7266:	ea 94       	dec	r14
    7268:	0f 5f       	subi	r16, 0xFF	; 255
    726a:	1f 4f       	sbci	r17, 0xFF	; 255
  for (i = 0; i < 4; ++i)
    726c:	e1 10       	cpse	r14, r1
    726e:	eb cf       	rjmp	.-42     	; 0x7246 <InvSubBytes+0x12>
    }
  }
}
    7270:	df 91       	pop	r29
    7272:	cf 91       	pop	r28
    7274:	1f 91       	pop	r17
    7276:	0f 91       	pop	r16
    7278:	ff 90       	pop	r15
    727a:	ef 90       	pop	r14
    727c:	08 95       	ret

0000727e <AES_init_ctx_iv>:
{
    727e:	7f 92       	push	r7
    7280:	8f 92       	push	r8
    7282:	9f 92       	push	r9
    7284:	af 92       	push	r10
    7286:	bf 92       	push	r11
    7288:	cf 92       	push	r12
    728a:	df 92       	push	r13
    728c:	ef 92       	push	r14
    728e:	ff 92       	push	r15
    7290:	0f 93       	push	r16
    7292:	1f 93       	push	r17
    7294:	cf 93       	push	r28
    7296:	df 93       	push	r29
    7298:	8c 01       	movw	r16, r24
    729a:	7a 01       	movw	r14, r20
    729c:	fb 01       	movw	r30, r22
    729e:	ec 01       	movw	r28, r24
    72a0:	cb 01       	movw	r24, r22
    72a2:	40 96       	adiw	r24, 0x10	; 16
  KeyExpansion(ctx->RoundKey, key);
    72a4:	d8 01       	movw	r26, r16
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    72a6:	20 81       	ld	r18, Z
    72a8:	2c 93       	st	X, r18
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    72aa:	21 81       	ldd	r18, Z+1	; 0x01
    72ac:	11 96       	adiw	r26, 0x01	; 1
    72ae:	2c 93       	st	X, r18
    72b0:	11 97       	sbiw	r26, 0x01	; 1
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    72b2:	22 81       	ldd	r18, Z+2	; 0x02
    72b4:	12 96       	adiw	r26, 0x02	; 2
    72b6:	2c 93       	st	X, r18
    72b8:	12 97       	sbiw	r26, 0x02	; 2
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    72ba:	23 81       	ldd	r18, Z+3	; 0x03
    72bc:	13 96       	adiw	r26, 0x03	; 3
    72be:	2c 93       	st	X, r18
    72c0:	13 97       	sbiw	r26, 0x03	; 3
    72c2:	34 96       	adiw	r30, 0x04	; 4
    72c4:	14 96       	adiw	r26, 0x04	; 4
  for (i = 0; i < Nk; ++i)
    72c6:	e8 17       	cp	r30, r24
    72c8:	f9 07       	cpc	r31, r25
    72ca:	69 f7       	brne	.-38     	; 0x72a6 <AES_init_ctx_iv+0x28>
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    72cc:	94 e0       	ldi	r25, 0x04	; 4
    72ce:	c9 2e       	mov	r12, r25
    72d0:	d1 2c       	mov	r13, r1
      tempa[0]=RoundKey[k + 0];
    72d2:	8c 84       	ldd	r8, Y+12	; 0x0c
      tempa[1]=RoundKey[k + 1];
    72d4:	ad 84       	ldd	r10, Y+13	; 0x0d
      tempa[2]=RoundKey[k + 2];
    72d6:	be 84       	ldd	r11, Y+14	; 0x0e
      tempa[3]=RoundKey[k + 3];
    72d8:	7f 84       	ldd	r7, Y+15	; 0x0f
    if (i % Nk == 0)
    72da:	c6 01       	movw	r24, r12
    72dc:	83 70       	andi	r24, 0x03	; 3
    72de:	99 27       	eor	r25, r25
    72e0:	89 2b       	or	r24, r25
    72e2:	71 f5       	brne	.+92     	; 0x7340 <AES_init_ctx_iv+0xc2>
        tempa[0] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[0]); //getSBoxValue(tempa[0]);
    72e4:	6a 2d       	mov	r22, r10
    72e6:	70 e0       	ldi	r23, 0x00	; 0
    72e8:	70 5f       	subi	r23, 0xF0	; 240
    72ea:	07 2e       	mov	r0, r23
    72ec:	00 0c       	add	r0, r0
    72ee:	88 0b       	sbc	r24, r24
    72f0:	99 0b       	sbc	r25, r25
    72f2:	59 df       	rcall	.-334    	; 0x71a6 <FLASH_readByte>
    72f4:	98 2e       	mov	r9, r24
        tempa[1] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[1]);//getSBoxValue(tempa[1]);
    72f6:	6b 2d       	mov	r22, r11
    72f8:	70 e0       	ldi	r23, 0x00	; 0
    72fa:	70 5f       	subi	r23, 0xF0	; 240
    72fc:	07 2e       	mov	r0, r23
    72fe:	00 0c       	add	r0, r0
    7300:	88 0b       	sbc	r24, r24
    7302:	99 0b       	sbc	r25, r25
    7304:	50 df       	rcall	.-352    	; 0x71a6 <FLASH_readByte>
    7306:	a8 2e       	mov	r10, r24
        tempa[2] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[2]);//getSBoxValue(tempa[2]);
    7308:	67 2d       	mov	r22, r7
    730a:	70 e0       	ldi	r23, 0x00	; 0
    730c:	70 5f       	subi	r23, 0xF0	; 240
    730e:	07 2e       	mov	r0, r23
    7310:	00 0c       	add	r0, r0
    7312:	88 0b       	sbc	r24, r24
    7314:	99 0b       	sbc	r25, r25
    7316:	47 df       	rcall	.-370    	; 0x71a6 <FLASH_readByte>
    7318:	b8 2e       	mov	r11, r24
        tempa[3] = FLASH_readByte(SECTOR_SBOX_VALUE + tempa[3]);//getSBoxValue(tempa[3]);
    731a:	68 2d       	mov	r22, r8
    731c:	70 e0       	ldi	r23, 0x00	; 0
    731e:	70 5f       	subi	r23, 0xF0	; 240
    7320:	07 2e       	mov	r0, r23
    7322:	00 0c       	add	r0, r0
    7324:	88 0b       	sbc	r24, r24
    7326:	99 0b       	sbc	r25, r25
    7328:	3e df       	rcall	.-388    	; 0x71a6 <FLASH_readByte>
    732a:	78 2e       	mov	r7, r24
      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    732c:	f6 01       	movw	r30, r12
    732e:	f6 95       	lsr	r31
    7330:	e7 95       	ror	r30
    7332:	f6 95       	lsr	r31
    7334:	e7 95       	ror	r30
    7336:	ef 5d       	subi	r30, 0xDF	; 223
    7338:	fe 4f       	sbci	r31, 0xFE	; 254
    733a:	60 81       	ld	r22, Z
    733c:	89 2c       	mov	r8, r9
    733e:	86 26       	eor	r8, r22
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    7340:	68 81       	ld	r22, Y
    7342:	68 25       	eor	r22, r8
    7344:	68 8b       	std	Y+16, r22	; 0x10
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    7346:	69 81       	ldd	r22, Y+1	; 0x01
    7348:	a6 26       	eor	r10, r22
    734a:	a9 8a       	std	Y+17, r10	; 0x11
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    734c:	6a 81       	ldd	r22, Y+2	; 0x02
    734e:	b6 26       	eor	r11, r22
    7350:	ba 8a       	std	Y+18, r11	; 0x12
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    7352:	6b 81       	ldd	r22, Y+3	; 0x03
    7354:	67 25       	eor	r22, r7
    7356:	6b 8b       	std	Y+19, r22	; 0x13
  for (i = Nk; i < Nb * (Nr + 1); ++i)
    7358:	8f ef       	ldi	r24, 0xFF	; 255
    735a:	c8 1a       	sub	r12, r24
    735c:	d8 0a       	sbc	r13, r24
    735e:	24 96       	adiw	r28, 0x04	; 4
    7360:	8c e2       	ldi	r24, 0x2C	; 44
    7362:	c8 16       	cp	r12, r24
    7364:	d1 04       	cpc	r13, r1
    7366:	09 f0       	breq	.+2      	; 0x736a <AES_init_ctx_iv+0xec>
    7368:	b4 cf       	rjmp	.-152    	; 0x72d2 <AES_init_ctx_iv+0x54>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
    736a:	d8 01       	movw	r26, r16
    736c:	a0 55       	subi	r26, 0x50	; 80
    736e:	bf 4f       	sbci	r27, 0xFF	; 255
    7370:	80 e1       	ldi	r24, 0x10	; 16
    7372:	f7 01       	movw	r30, r14
    7374:	01 90       	ld	r0, Z+
    7376:	0d 92       	st	X+, r0
    7378:	8a 95       	dec	r24
    737a:	e1 f7       	brne	.-8      	; 0x7374 <AES_init_ctx_iv+0xf6>
}
    737c:	df 91       	pop	r29
    737e:	cf 91       	pop	r28
    7380:	1f 91       	pop	r17
    7382:	0f 91       	pop	r16
    7384:	ff 90       	pop	r15
    7386:	ef 90       	pop	r14
    7388:	df 90       	pop	r13
    738a:	cf 90       	pop	r12
    738c:	bf 90       	pop	r11
    738e:	af 90       	pop	r10
    7390:	9f 90       	pop	r9
    7392:	8f 90       	pop	r8
    7394:	7f 90       	pop	r7
    7396:	08 95       	ret

00007398 <AES_CBC_decrypt_buffer>:
    buf[i] ^= Iv[i];
  }
}

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf,  uint32_t length)
{
    7398:	2f 92       	push	r2
    739a:	3f 92       	push	r3
    739c:	4f 92       	push	r4
    739e:	5f 92       	push	r5
    73a0:	6f 92       	push	r6
    73a2:	7f 92       	push	r7
    73a4:	8f 92       	push	r8
    73a6:	9f 92       	push	r9
    73a8:	af 92       	push	r10
    73aa:	bf 92       	push	r11
    73ac:	cf 92       	push	r12
    73ae:	df 92       	push	r13
    73b0:	ef 92       	push	r14
    73b2:	ff 92       	push	r15
    73b4:	0f 93       	push	r16
    73b6:	1f 93       	push	r17
    73b8:	cf 93       	push	r28
    73ba:	df 93       	push	r29
    73bc:	cd b7       	in	r28, 0x3d	; 61
    73be:	de b7       	in	r29, 0x3e	; 62
    73c0:	a0 97       	sbiw	r28, 0x20	; 32
    73c2:	0f b6       	in	r0, 0x3f	; 63
    73c4:	f8 94       	cli
    73c6:	de bf       	out	0x3e, r29	; 62
    73c8:	0f be       	out	0x3f, r0	; 63
    73ca:	cd bf       	out	0x3d, r28	; 61
    73cc:	3c 01       	movw	r6, r24
    73ce:	7c 8f       	std	Y+28, r23	; 0x1c
    73d0:	6b 8f       	std	Y+27, r22	; 0x1b
    73d2:	2d 8f       	std	Y+29, r18	; 0x1d
    73d4:	3e 8f       	std	Y+30, r19	; 0x1e
    73d6:	4f 8f       	std	Y+31, r20	; 0x1f
    73d8:	58 a3       	std	Y+32, r21	; 0x20
    73da:	9b 01       	movw	r18, r22
    73dc:	20 5f       	subi	r18, 0xF0	; 240
    73de:	3f 4f       	sbci	r19, 0xFF	; 255
    73e0:	3a 8f       	std	Y+26, r19	; 0x1a
    73e2:	29 8f       	std	Y+25, r18	; 0x19
  uintptr_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
    73e4:	8b 01       	movw	r16, r22
    73e6:	1c 8b       	std	Y+20, r17	; 0x14
    73e8:	0b 8b       	std	Y+19, r16	; 0x13
    73ea:	c8 01       	movw	r24, r16
    73ec:	eb 8d       	ldd	r30, Y+27	; 0x1b
    73ee:	fc 8d       	ldd	r31, Y+28	; 0x1c
    73f0:	8e 1b       	sub	r24, r30
    73f2:	9f 0b       	sbc	r25, r31
    73f4:	b0 e0       	ldi	r27, 0x00	; 0
    73f6:	a0 e0       	ldi	r26, 0x00	; 0
    73f8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    73fa:	3e 8d       	ldd	r19, Y+30	; 0x1e
    73fc:	4f 8d       	ldd	r20, Y+31	; 0x1f
    73fe:	58 a1       	ldd	r21, Y+32	; 0x20
    7400:	82 17       	cp	r24, r18
    7402:	93 07       	cpc	r25, r19
    7404:	a4 07       	cpc	r26, r20
    7406:	b5 07       	cpc	r27, r21
    7408:	c8 f0       	brcs	.+50     	; 0x743c <AES_CBC_decrypt_buffer+0xa4>
    XorWithIv(buf, ctx->Iv);
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    buf += AES_BLOCKLEN;
  }

}
    740a:	a0 96       	adiw	r28, 0x20	; 32
    740c:	0f b6       	in	r0, 0x3f	; 63
    740e:	f8 94       	cli
    7410:	de bf       	out	0x3e, r29	; 62
    7412:	0f be       	out	0x3f, r0	; 63
    7414:	cd bf       	out	0x3d, r28	; 61
    7416:	df 91       	pop	r29
    7418:	cf 91       	pop	r28
    741a:	1f 91       	pop	r17
    741c:	0f 91       	pop	r16
    741e:	ff 90       	pop	r15
    7420:	ef 90       	pop	r14
    7422:	df 90       	pop	r13
    7424:	cf 90       	pop	r12
    7426:	bf 90       	pop	r11
    7428:	af 90       	pop	r10
    742a:	9f 90       	pop	r9
    742c:	8f 90       	pop	r8
    742e:	7f 90       	pop	r7
    7430:	6f 90       	pop	r6
    7432:	5f 90       	pop	r5
    7434:	4f 90       	pop	r4
    7436:	3f 90       	pop	r3
    7438:	2f 90       	pop	r2
    743a:	08 95       	ret
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    743c:	80 e1       	ldi	r24, 0x10	; 16
    743e:	f8 01       	movw	r30, r16
    7440:	de 01       	movw	r26, r28
    7442:	11 96       	adiw	r26, 0x01	; 1
    7444:	01 90       	ld	r0, Z+
    7446:	0d 92       	st	X+, r0
    7448:	8a 95       	dec	r24
    744a:	e1 f7       	brne	.-8      	; 0x7444 <AES_CBC_decrypt_buffer+0xac>
  AddRoundKey(Nr, state, RoundKey); 
    744c:	a3 01       	movw	r20, r6
    744e:	b8 01       	movw	r22, r16
    7450:	8a e0       	ldi	r24, 0x0A	; 10
    7452:	c1 de       	rcall	.-638    	; 0x71d6 <AddRoundKey>
  for (round = (Nr - 1); round > 0; --round)
    7454:	39 e0       	ldi	r19, 0x09	; 9
    7456:	39 8b       	std	Y+17, r19	; 0x11
  temp = (*state)[3][1];
    7458:	f8 01       	movw	r30, r16
    745a:	85 85       	ldd	r24, Z+13	; 0x0d
  (*state)[3][1] = (*state)[2][1];
    745c:	91 85       	ldd	r25, Z+9	; 0x09
    745e:	95 87       	std	Z+13, r25	; 0x0d
  (*state)[2][1] = (*state)[1][1];
    7460:	95 81       	ldd	r25, Z+5	; 0x05
    7462:	91 87       	std	Z+9, r25	; 0x09
  (*state)[1][1] = (*state)[0][1];
    7464:	91 81       	ldd	r25, Z+1	; 0x01
    7466:	95 83       	std	Z+5, r25	; 0x05
  (*state)[0][1] = temp;
    7468:	81 83       	std	Z+1, r24	; 0x01
  temp = (*state)[0][2];
    746a:	82 81       	ldd	r24, Z+2	; 0x02
  (*state)[0][2] = (*state)[2][2];
    746c:	92 85       	ldd	r25, Z+10	; 0x0a
    746e:	92 83       	std	Z+2, r25	; 0x02
  (*state)[2][2] = temp;
    7470:	82 87       	std	Z+10, r24	; 0x0a
  temp = (*state)[1][2];
    7472:	86 81       	ldd	r24, Z+6	; 0x06
  (*state)[1][2] = (*state)[3][2];
    7474:	96 85       	ldd	r25, Z+14	; 0x0e
    7476:	96 83       	std	Z+6, r25	; 0x06
  (*state)[3][2] = temp;
    7478:	86 87       	std	Z+14, r24	; 0x0e
  temp = (*state)[0][3];
    747a:	83 81       	ldd	r24, Z+3	; 0x03
  (*state)[0][3] = (*state)[1][3];
    747c:	97 81       	ldd	r25, Z+7	; 0x07
    747e:	93 83       	std	Z+3, r25	; 0x03
  (*state)[1][3] = (*state)[2][3];
    7480:	93 85       	ldd	r25, Z+11	; 0x0b
    7482:	97 83       	std	Z+7, r25	; 0x07
  (*state)[2][3] = (*state)[3][3];
    7484:	97 85       	ldd	r25, Z+15	; 0x0f
    7486:	93 87       	std	Z+11, r25	; 0x0b
    InvSubBytes(state);
    7488:	87 87       	std	Z+15, r24	; 0x0f
    748a:	c8 01       	movw	r24, r16
    AddRoundKey(round, state, RoundKey);
    748c:	d3 de       	rcall	.-602    	; 0x7234 <InvSubBytes>
    748e:	a3 01       	movw	r20, r6
    7490:	b8 01       	movw	r22, r16
    7492:	89 89       	ldd	r24, Y+17	; 0x11
    7494:	a0 de       	rcall	.-704    	; 0x71d6 <AddRoundKey>
    a = (*state)[i][0];
    7496:	28 01       	movw	r4, r16
    7498:	f2 01       	movw	r30, r4
    b = (*state)[i][1];
    749a:	30 80       	ld	r3, Z
    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    749c:	d1 80       	ldd	r13, Z+1	; 0x01
    749e:	e2 80       	ldd	r14, Z+2	; 0x02
    74a0:	f3 81       	ldd	r31, Z+3	; 0x03
    74a2:	fa 8b       	std	Y+18, r31	; 0x12
    74a4:	83 2d       	mov	r24, r3
    74a6:	bb de       	rcall	.-650    	; 0x721e <xtime>
    74a8:	f8 2e       	mov	r15, r24
    74aa:	b9 de       	rcall	.-654    	; 0x721e <xtime>
    74ac:	8d 8b       	std	Y+21, r24	; 0x15
    74ae:	b7 de       	rcall	.-658    	; 0x721e <xtime>
    74b0:	b8 2e       	mov	r11, r24
    74b2:	8d 2d       	mov	r24, r13
    74b4:	b4 de       	rcall	.-664    	; 0x721e <xtime>
    74b6:	8e 8b       	std	Y+22, r24	; 0x16
    74b8:	b2 de       	rcall	.-668    	; 0x721e <xtime>
    74ba:	88 2e       	mov	r8, r24
    74bc:	b0 de       	rcall	.-672    	; 0x721e <xtime>
    74be:	c8 2e       	mov	r12, r24
    74c0:	8e 2d       	mov	r24, r14
    74c2:	ad de       	rcall	.-678    	; 0x721e <xtime>
    74c4:	8f 8b       	std	Y+23, r24	; 0x17
    74c6:	ab de       	rcall	.-682    	; 0x721e <xtime>
    74c8:	88 8f       	std	Y+24, r24	; 0x18
    74ca:	a9 de       	rcall	.-686    	; 0x721e <xtime>
    74cc:	28 2e       	mov	r2, r24
    74ce:	8a 89       	ldd	r24, Y+18	; 0x12
    74d0:	a6 de       	rcall	.-692    	; 0x721e <xtime>
    74d2:	98 2e       	mov	r9, r24
    74d4:	a4 de       	rcall	.-696    	; 0x721e <xtime>
    74d6:	a8 2e       	mov	r10, r24
    74d8:	a2 de       	rcall	.-700    	; 0x721e <xtime>
    74da:	9d 89       	ldd	r25, Y+21	; 0x15
    74dc:	9f 25       	eor	r25, r15
    74de:	9b 25       	eor	r25, r11
    74e0:	2e 89       	ldd	r18, Y+22	; 0x16
    74e2:	92 27       	eor	r25, r18
    74e4:	9c 25       	eor	r25, r12
    74e6:	38 8d       	ldd	r19, Y+24	; 0x18
    74e8:	93 27       	eor	r25, r19
    74ea:	92 25       	eor	r25, r2
    74ec:	98 27       	eor	r25, r24
    74ee:	9d 25       	eor	r25, r13
    74f0:	9e 25       	eor	r25, r14
    74f2:	4a 89       	ldd	r20, Y+18	; 0x12
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    74f4:	94 27       	eor	r25, r20
    74f6:	f2 01       	movw	r30, r4
    74f8:	90 83       	st	Z, r25
    74fa:	92 2f       	mov	r25, r18
    74fc:	9b 25       	eor	r25, r11
    74fe:	98 25       	eor	r25, r8
    7500:	9c 25       	eor	r25, r12
    7502:	ff 89       	ldd	r31, Y+23	; 0x17
    7504:	9f 27       	eor	r25, r31
    7506:	92 25       	eor	r25, r2
    7508:	9a 25       	eor	r25, r10
    750a:	98 27       	eor	r25, r24
    750c:	93 25       	eor	r25, r3
    750e:	9e 25       	eor	r25, r14
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    7510:	94 27       	eor	r25, r20
    7512:	f2 01       	movw	r30, r4
    7514:	91 83       	std	Z+1, r25	; 0x01
    7516:	9d 89       	ldd	r25, Y+21	; 0x15
    7518:	9b 25       	eor	r25, r11
    751a:	9c 25       	eor	r25, r12
    751c:	ff 89       	ldd	r31, Y+23	; 0x17
    751e:	9f 27       	eor	r25, r31
    7520:	93 27       	eor	r25, r19
    7522:	92 25       	eor	r25, r2
    7524:	99 25       	eor	r25, r9
    7526:	98 27       	eor	r25, r24
    7528:	93 25       	eor	r25, r3
    752a:	9d 25       	eor	r25, r13
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
    752c:	94 27       	eor	r25, r20
    752e:	f2 01       	movw	r30, r4
    7530:	92 83       	std	Z+2, r25	; 0x02
    7532:	fb 24       	eor	r15, r11
    7534:	8f 24       	eor	r8, r15
    7536:	c8 24       	eor	r12, r8
    7538:	c2 24       	eor	r12, r2
    753a:	9c 24       	eor	r9, r12
    753c:	a9 24       	eor	r10, r9
    753e:	a8 26       	eor	r10, r24
    7540:	a3 24       	eor	r10, r3
    7542:	ad 24       	eor	r10, r13
    7544:	ae 24       	eor	r10, r14
    7546:	a3 82       	std	Z+3, r10	; 0x03
  for (i = 0; i < 4; ++i)
    7548:	f4 e0       	ldi	r31, 0x04	; 4
    754a:	4f 0e       	add	r4, r31
    754c:	51 1c       	adc	r5, r1
    754e:	29 8d       	ldd	r18, Y+25	; 0x19
    7550:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7552:	24 15       	cp	r18, r4
  for (round = (Nr - 1); round > 0; --round)
    7554:	35 05       	cpc	r19, r5
    7556:	09 f0       	breq	.+2      	; 0x755a <AES_CBC_decrypt_buffer+0x1c2>
    7558:	9f cf       	rjmp	.-194    	; 0x7498 <AES_CBC_decrypt_buffer+0x100>
    755a:	39 89       	ldd	r19, Y+17	; 0x11
    755c:	31 50       	subi	r19, 0x01	; 1
  temp = (*state)[3][1];
    755e:	39 8b       	std	Y+17, r19	; 0x11
    7560:	31 11       	cpse	r19, r1
  (*state)[3][1] = (*state)[2][1];
    7562:	7a cf       	rjmp	.-268    	; 0x7458 <AES_CBC_decrypt_buffer+0xc0>
    7564:	f8 01       	movw	r30, r16
  (*state)[2][1] = (*state)[1][1];
    7566:	85 85       	ldd	r24, Z+13	; 0x0d
    7568:	91 85       	ldd	r25, Z+9	; 0x09
  (*state)[1][1] = (*state)[0][1];
    756a:	95 87       	std	Z+13, r25	; 0x0d
    756c:	95 81       	ldd	r25, Z+5	; 0x05
  (*state)[0][1] = temp;
    756e:	91 87       	std	Z+9, r25	; 0x09
  temp = (*state)[0][2];
    7570:	91 81       	ldd	r25, Z+1	; 0x01
  (*state)[0][2] = (*state)[2][2];
    7572:	95 83       	std	Z+5, r25	; 0x05
  (*state)[2][2] = temp;
    7574:	81 83       	std	Z+1, r24	; 0x01
  temp = (*state)[1][2];
    7576:	82 81       	ldd	r24, Z+2	; 0x02
  (*state)[1][2] = (*state)[3][2];
    7578:	92 85       	ldd	r25, Z+10	; 0x0a
  (*state)[3][2] = temp;
    757a:	92 83       	std	Z+2, r25	; 0x02
  temp = (*state)[0][3];
    757c:	82 87       	std	Z+10, r24	; 0x0a
  (*state)[0][3] = (*state)[1][3];
    757e:	86 81       	ldd	r24, Z+6	; 0x06
    7580:	96 85       	ldd	r25, Z+14	; 0x0e
  (*state)[1][3] = (*state)[2][3];
    7582:	96 83       	std	Z+6, r25	; 0x06
    7584:	86 87       	std	Z+14, r24	; 0x0e
  (*state)[2][3] = (*state)[3][3];
    7586:	83 81       	ldd	r24, Z+3	; 0x03
    7588:	97 81       	ldd	r25, Z+7	; 0x07
  (*state)[3][3] = temp;
    758a:	93 83       	std	Z+3, r25	; 0x03
  InvSubBytes(state);
    758c:	93 85       	ldd	r25, Z+11	; 0x0b
    758e:	97 83       	std	Z+7, r25	; 0x07
    7590:	97 85       	ldd	r25, Z+15	; 0x0f
  AddRoundKey(0, state, RoundKey);
    7592:	93 87       	std	Z+11, r25	; 0x0b
    7594:	87 87       	std	Z+15, r24	; 0x0f
    7596:	c8 01       	movw	r24, r16
    7598:	4d de       	rcall	.-870    	; 0x7234 <InvSubBytes>
    759a:	a3 01       	movw	r20, r6
    XorWithIv(buf, ctx->Iv);
    759c:	b8 01       	movw	r22, r16
    759e:	80 e0       	ldi	r24, 0x00	; 0
    75a0:	1a de       	rcall	.-972    	; 0x71d6 <AddRoundKey>
    75a2:	a3 01       	movw	r20, r6
    buf[i] ^= Iv[i];
    75a4:	40 55       	subi	r20, 0x50	; 80
    75a6:	5f 4f       	sbci	r21, 0xFF	; 255
    75a8:	da 01       	movw	r26, r20
    75aa:	eb 89       	ldd	r30, Y+19	; 0x13
    75ac:	fc 89       	ldd	r31, Y+20	; 0x14
    75ae:	81 91       	ld	r24, Z+
    75b0:	fc 8b       	std	Y+20, r31	; 0x14
    75b2:	eb 8b       	std	Y+19, r30	; 0x13
    75b4:	fa 01       	movw	r30, r20
    75b6:	91 91       	ld	r25, Z+
    75b8:	af 01       	movw	r20, r30
    75ba:	2b 89       	ldd	r18, Y+19	; 0x13
    75bc:	3c 89       	ldd	r19, Y+20	; 0x14
    75be:	21 50       	subi	r18, 0x01	; 1
    75c0:	31 09       	sbc	r19, r1
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
    75c2:	89 27       	eor	r24, r25
    75c4:	f9 01       	movw	r30, r18
    75c6:	80 83       	st	Z, r24
    75c8:	2b 89       	ldd	r18, Y+19	; 0x13
    75ca:	3c 89       	ldd	r19, Y+20	; 0x14
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    75cc:	42 16       	cp	r4, r18
    75ce:	53 06       	cpc	r5, r19
    75d0:	61 f7       	brne	.-40     	; 0x75aa <AES_CBC_decrypt_buffer+0x212>
    75d2:	80 e1       	ldi	r24, 0x10	; 16
    75d4:	fe 01       	movw	r30, r28
    75d6:	31 96       	adiw	r30, 0x01	; 1
    75d8:	01 90       	ld	r0, Z+
    buf += AES_BLOCKLEN;
    75da:	0d 92       	st	X+, r0
    75dc:	8a 95       	dec	r24
    75de:	e1 f7       	brne	.-8      	; 0x75d8 <AES_CBC_decrypt_buffer+0x240>
    75e0:	00 5f       	subi	r16, 0xF0	; 240
    75e2:	1f 4f       	sbci	r17, 0xFF	; 255
    75e4:	49 8d       	ldd	r20, Y+25	; 0x19
    75e6:	5a 8d       	ldd	r21, Y+26	; 0x1a
    75e8:	40 5f       	subi	r20, 0xF0	; 240
    75ea:	5f 4f       	sbci	r21, 0xFF	; 255
    75ec:	5a 8f       	std	Y+26, r21	; 0x1a
    75ee:	49 8f       	std	Y+25, r20	; 0x19
    75f0:	fa ce       	rjmp	.-524    	; 0x73e6 <AES_CBC_decrypt_buffer+0x4e>

000075f2 <StartSketch>:

/* Calculate 8 bit crc */
void crc8(uint8_t *crc, char data)
{
  (*crc) ^= ((uint8_t) data);
}
    75f2:	f8 94       	cli
    75f4:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    75f8:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    75fc:	81 e0       	ldi	r24, 0x01	; 1
    75fe:	85 bf       	out	0x35, r24	; 53
    7600:	15 be       	out	0x35, r1	; 53
    7602:	47 98       	cbi	0x08, 7	; 8
    7604:	5d 9a       	sbi	0x0b, 5	; 11
    7606:	28 9a       	sbi	0x05, 0	; 5
    7608:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    760c:	08 95       	ret

0000760e <Init>:
    760e:	10 92 11 02 	sts	0x0211, r1	; 0x800211 <strAddr>
    7612:	10 92 12 02 	sts	0x0212, r1	; 0x800212 <strAddr+0x1>
    7616:	10 92 13 02 	sts	0x0213, r1	; 0x800213 <strAddr+0x2>
    761a:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <strAddr+0x3>
    761e:	10 92 ed 01 	sts	0x01ED, r1	; 0x8001ed <current_byte+0x1>
    7622:	10 92 ec 01 	sts	0x01EC, r1	; 0x8001ec <current_byte>
    7626:	10 92 16 02 	sts	0x0216, r1	; 0x800216 <nextAddress+0x1>
    762a:	10 92 15 02 	sts	0x0215, r1	; 0x800215 <nextAddress>
    762e:	e0 ef       	ldi	r30, 0xF0	; 240
    7630:	f1 e0       	ldi	r31, 0x01	; 1
    7632:	80 e2       	ldi	r24, 0x20	; 32
    7634:	df 01       	movw	r26, r30
    7636:	1d 92       	st	X+, r1
    7638:	8a 95       	dec	r24
    763a:	e9 f7       	brne	.-6      	; 0x7636 <Init+0x28>
    763c:	8c b5       	in	r24, 0x2c	; 44
    763e:	80 65       	ori	r24, 0x50	; 80
    7640:	8c bd       	out	0x2c, r24	; 44
    7642:	73 dd       	rcall	.-1306   	; 0x712a <SPI_init>
    7644:	40 e0       	ldi	r20, 0x00	; 0
    7646:	51 e0       	ldi	r21, 0x01	; 1
    7648:	60 e1       	ldi	r22, 0x10	; 16
    764a:	71 e0       	ldi	r23, 0x01	; 1
    764c:	8c e2       	ldi	r24, 0x2C	; 44
    764e:	91 e0       	ldi	r25, 0x01	; 1
    7650:	16 ce       	rjmp	.-980    	; 0x727e <AES_init_ctx_iv>

00007652 <line_checksum>:
bool line_checksum(void){

    uint8_t calculated_crc_line = 0;
    uint16_t b;
   /* the checksum is computed by taking the data length byte + 2 byte for address + data */
    for(uint8_t i = 1; i <= buffer[0]; i++){
    7652:	20 91 f0 01 	lds	r18, 0x01F0	; 0x8001f0 <buffer>
    uint8_t calculated_crc_line = 0;
    7656:	90 e0       	ldi	r25, 0x00	; 0
    for(uint8_t i = 1; i <= buffer[0]; i++){
    7658:	81 e0       	ldi	r24, 0x01	; 1
    765a:	28 17       	cp	r18, r24
    765c:	68 f4       	brcc	.+26     	; 0x7678 <line_checksum+0x26>
        crc8(&calculated_crc_line,(uint8_t) buffer[i]);
    }

    if((uint8_t)buffer[17] != calculated_crc_line){
    765e:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <buffer+0x11>
    7662:	89 13       	cpse	r24, r25
    7664:	55 c0       	rjmp	.+170    	; 0x7710 <line_checksum+0xbe>
    		return false;	
    }else{
        for(uint8_t i = 1; i < buffer[0]; i+=2){
    7666:	81 e0       	ldi	r24, 0x01	; 1
           
            b  = buffer[i] & 0xFF;
            b |= buffer[i + 1] << 8;
            boot_page_fill(current_byte,b);
    7668:	41 e0       	ldi	r20, 0x01	; 1
            current_byte += 2;
       if ((current_byte%SPM_PAGESIZE==0 || current_byte==imagesize)){ 
         TX_LED_ON();
         // Write from programming buffer
         boot_page_write(nextAddress); //(current_byte+2-SPM_PAGESIZE)
    766a:	55 e0       	ldi	r21, 0x05	; 5
        for(uint8_t i = 1; i < buffer[0]; i+=2){
    766c:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <buffer>
    7670:	89 17       	cp	r24, r25
    7672:	50 f0       	brcs	.+20     	; 0x7688 <line_checksum+0x36>
        	}
        }
      }
    }

    return true;
    7674:	81 e0       	ldi	r24, 0x01	; 1
    7676:	08 95       	ret
        crc8(&calculated_crc_line,(uint8_t) buffer[i]);
    7678:	e8 2f       	mov	r30, r24
    767a:	f0 e0       	ldi	r31, 0x00	; 0
    767c:	e0 51       	subi	r30, 0x10	; 16
    767e:	fe 4f       	sbci	r31, 0xFE	; 254
  (*crc) ^= ((uint8_t) data);
    7680:	30 81       	ld	r19, Z
    7682:	93 27       	eor	r25, r19
    for(uint8_t i = 1; i <= buffer[0]; i++){
    7684:	8f 5f       	subi	r24, 0xFF	; 255
    7686:	e9 cf       	rjmp	.-46     	; 0x765a <line_checksum+0x8>
            b  = buffer[i] & 0xFF;
    7688:	a8 2f       	mov	r26, r24
    768a:	b0 e0       	ldi	r27, 0x00	; 0
    768c:	a0 51       	subi	r26, 0x10	; 16
    768e:	be 4f       	sbci	r27, 0xFE	; 254
    7690:	9c 91       	ld	r25, X
            boot_page_fill(current_byte,b);
    7692:	e0 91 ec 01 	lds	r30, 0x01EC	; 0x8001ec <current_byte>
    7696:	f0 91 ed 01 	lds	r31, 0x01ED	; 0x8001ed <current_byte+0x1>
            b |= buffer[i + 1] << 8;
    769a:	11 96       	adiw	r26, 0x01	; 1
    769c:	2c 91       	ld	r18, X
    769e:	32 2f       	mov	r19, r18
    76a0:	29 2f       	mov	r18, r25
            boot_page_fill(current_byte,b);
    76a2:	09 01       	movw	r0, r18
    76a4:	40 93 57 00 	sts	0x0057, r20	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    76a8:	e8 95       	spm
    76aa:	11 24       	eor	r1, r1
            current_byte += 2;
    76ac:	32 96       	adiw	r30, 0x02	; 2
    76ae:	f0 93 ed 01 	sts	0x01ED, r31	; 0x8001ed <current_byte+0x1>
    76b2:	e0 93 ec 01 	sts	0x01EC, r30	; 0x8001ec <current_byte>
       if ((current_byte%SPM_PAGESIZE==0 || current_byte==imagesize)){ 
    76b6:	9f 01       	movw	r18, r30
    76b8:	2f 77       	andi	r18, 0x7F	; 127
    76ba:	33 27       	eor	r19, r19
    76bc:	23 2b       	or	r18, r19
    76be:	39 f0       	breq	.+14     	; 0x76ce <line_checksum+0x7c>
    76c0:	20 91 ee 01 	lds	r18, 0x01EE	; 0x8001ee <imagesize>
    76c4:	30 91 ef 01 	lds	r19, 0x01EF	; 0x8001ef <imagesize+0x1>
    76c8:	e2 17       	cp	r30, r18
    76ca:	f3 07       	cpc	r31, r19
    76cc:	f9 f4       	brne	.+62     	; 0x770c <line_checksum+0xba>
         TX_LED_ON();
    76ce:	5d 98       	cbi	0x0b, 5	; 11
         boot_page_write(nextAddress); //(current_byte+2-SPM_PAGESIZE)
    76d0:	e0 91 15 02 	lds	r30, 0x0215	; 0x800215 <nextAddress>
    76d4:	f0 91 16 02 	lds	r31, 0x0216	; 0x800216 <nextAddress+0x1>
    76d8:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    76dc:	e8 95       	spm
         boot_spm_busy_wait();
    76de:	07 b6       	in	r0, 0x37	; 55
    76e0:	00 fc       	sbrc	r0, 0
    76e2:	fd cf       	rjmp	.-6      	; 0x76de <line_checksum+0x8c>
         nextAddress += SPM_PAGESIZE;
    76e4:	e0 58       	subi	r30, 0x80	; 128
    76e6:	ff 4f       	sbci	r31, 0xFF	; 255
    76e8:	f0 93 16 02 	sts	0x0216, r31	; 0x800216 <nextAddress+0x1>
    76ec:	e0 93 15 02 	sts	0x0215, r30	; 0x800215 <nextAddress>
         	TX_LED_OFF();
    76f0:	5d 9a       	sbi	0x0b, 5	; 11
        if(current_byte == imagesize){ 
    76f2:	60 91 ec 01 	lds	r22, 0x01EC	; 0x8001ec <current_byte>
    76f6:	70 91 ed 01 	lds	r23, 0x01ED	; 0x8001ed <current_byte+0x1>
    76fa:	20 91 ee 01 	lds	r18, 0x01EE	; 0x8001ee <imagesize>
    76fe:	30 91 ef 01 	lds	r19, 0x01EF	; 0x8001ef <imagesize+0x1>
    7702:	62 17       	cp	r22, r18
    7704:	73 07       	cpc	r23, r19
    7706:	11 f4       	brne	.+4      	; 0x770c <line_checksum+0xba>
        	RunBootloader = false;  	
    7708:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <RunBootloader>
        for(uint8_t i = 1; i < buffer[0]; i+=2){
    770c:	8e 5f       	subi	r24, 0xFE	; 254
    770e:	ae cf       	rjmp	.-164    	; 0x766c <line_checksum+0x1a>
    		return false;	
    7710:	80 e0       	ldi	r24, 0x00	; 0
    7712:	08 95       	ret

00007714 <SPI_FlashImage>:
void SPI_FlashImage(void){
    7714:	cf 93       	push	r28
    imagesize = ((FLASH_readByte((uint32_t)SECTOR_LENGTH(SECTOR_1_START_ADDRESS))) << 8) | ((FLASH_readByte((uint32_t) (SECTOR_LENGTH(SECTOR_1_START_ADDRESS) + 0x01))) & 0xFF) ;
    7716:	63 e0       	ldi	r22, 0x03	; 3
    7718:	70 e2       	ldi	r23, 0x20	; 32
    771a:	80 e0       	ldi	r24, 0x00	; 0
    771c:	90 e0       	ldi	r25, 0x00	; 0
    771e:	43 dd       	rcall	.-1402   	; 0x71a6 <FLASH_readByte>
    7720:	c8 2f       	mov	r28, r24
    7722:	64 e0       	ldi	r22, 0x04	; 4
    7724:	70 e2       	ldi	r23, 0x20	; 32
    7726:	80 e0       	ldi	r24, 0x00	; 0
    7728:	90 e0       	ldi	r25, 0x00	; 0
    772a:	3d dd       	rcall	.-1414   	; 0x71a6 <FLASH_readByte>
    772c:	9c 2f       	mov	r25, r28
    772e:	90 93 ef 01 	sts	0x01EF, r25	; 0x8001ef <imagesize+0x1>
    7732:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <imagesize>
    if (imagesize%2!=0) return; /* basic check that we got even # of bytes */
    7736:	80 fd       	sbrc	r24, 0
    7738:	4c c0       	rjmp	.+152    	; 0x77d2 <SPI_FlashImage+0xbe>
    strAddr = SECTOR_1_START_ADDRESS + SECTOR_OFFSET;
    773a:	85 e0       	ldi	r24, 0x05	; 5
    773c:	90 e2       	ldi	r25, 0x20	; 32
    773e:	a0 e0       	ldi	r26, 0x00	; 0
    7740:	b0 e0       	ldi	r27, 0x00	; 0
    7742:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <strAddr>
    7746:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <strAddr+0x1>
    774a:	a0 93 13 02 	sts	0x0213, r26	; 0x800213 <strAddr+0x2>
    774e:	b0 93 14 02 	sts	0x0214, r27	; 0x800214 <strAddr+0x3>
       read_data = FLASH_readByte(strAddr);
    7752:	60 91 11 02 	lds	r22, 0x0211	; 0x800211 <strAddr>
    7756:	70 91 12 02 	lds	r23, 0x0212	; 0x800212 <strAddr+0x1>
    775a:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <strAddr+0x2>
    775e:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <strAddr+0x3>
    7762:	21 dd       	rcall	.-1470   	; 0x71a6 <FLASH_readByte>
    7764:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <read_data>
        if(read_data == 0xFF){
    7768:	8f 3f       	cpi	r24, 0xFF	; 255
    776a:	99 f1       	breq	.+102    	; 0x77d2 <SPI_FlashImage+0xbe>
        Flash_readByteArray(buffer,strAddr + 0x01,read_data + 0x01);
    776c:	21 e0       	ldi	r18, 0x01	; 1
    776e:	28 0f       	add	r18, r24
    7770:	40 91 11 02 	lds	r20, 0x0211	; 0x800211 <strAddr>
    7774:	50 91 12 02 	lds	r21, 0x0212	; 0x800212 <strAddr+0x1>
    7778:	60 91 13 02 	lds	r22, 0x0213	; 0x800213 <strAddr+0x2>
    777c:	70 91 14 02 	lds	r23, 0x0214	; 0x800214 <strAddr+0x3>
    7780:	4f 5f       	subi	r20, 0xFF	; 255
    7782:	5f 4f       	sbci	r21, 0xFF	; 255
    7784:	6f 4f       	sbci	r22, 0xFF	; 255
    7786:	7f 4f       	sbci	r23, 0xFF	; 255
    7788:	80 ef       	ldi	r24, 0xF0	; 240
    778a:	91 e0       	ldi	r25, 0x01	; 1
    778c:	df dc       	rcall	.-1602   	; 0x714c <Flash_readByteArray>
		    AES_CBC_decrypt_buffer(&ctx,(uint8_t *) &buffer[1], read_data - 0x01);
    778e:	20 91 10 02 	lds	r18, 0x0210	; 0x800210 <read_data>
    7792:	21 50       	subi	r18, 0x01	; 1
    7794:	33 0b       	sbc	r19, r19
    7796:	03 2e       	mov	r0, r19
    7798:	00 0c       	add	r0, r0
    779a:	44 0b       	sbc	r20, r20
    779c:	55 0b       	sbc	r21, r21
    779e:	61 ef       	ldi	r22, 0xF1	; 241
    77a0:	71 e0       	ldi	r23, 0x01	; 1
    77a2:	8c e2       	ldi	r24, 0x2C	; 44
    77a4:	91 e0       	ldi	r25, 0x01	; 1
        if(!line_checksum()){
    77a6:	f8 dd       	rcall	.-1040   	; 0x7398 <AES_CBC_decrypt_buffer>
    77a8:	54 df       	rcall	.-344    	; 0x7652 <line_checksum>
    77aa:	88 23       	and	r24, r24
    77ac:	91 f0       	breq	.+36     	; 0x77d2 <SPI_FlashImage+0xbe>
        strAddr += (uint32_t) read_data + 0x02; 
    77ae:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <strAddr>
    77b2:	90 91 12 02 	lds	r25, 0x0212	; 0x800212 <strAddr+0x1>
    77b6:	a0 91 13 02 	lds	r26, 0x0213	; 0x800213 <strAddr+0x2>
    77ba:	b0 91 14 02 	lds	r27, 0x0214	; 0x800214 <strAddr+0x3>
    77be:	02 96       	adiw	r24, 0x02	; 2
    77c0:	a1 1d       	adc	r26, r1
    77c2:	b1 1d       	adc	r27, r1
    77c4:	20 91 10 02 	lds	r18, 0x0210	; 0x800210 <read_data>
    77c8:	82 0f       	add	r24, r18
    77ca:	91 1d       	adc	r25, r1
    77cc:	a1 1d       	adc	r26, r1
    77ce:	b1 1d       	adc	r27, r1
    77d0:	b8 cf       	rjmp	.-144    	; 0x7742 <SPI_FlashImage+0x2e>
}
    77d2:	cf 91       	pop	r28
    77d4:	08 95       	ret

000077d6 <main>:
{
    77d6:	cf 93       	push	r28
	MCUSR = 0;							// clear all reset flags	
    77d8:	14 be       	out	0x34, r1	; 52
	MCUCR = (1 << IVCE);
    77da:	81 e0       	ldi	r24, 0x01	; 1
    77dc:	85 bf       	out	0x35, r24	; 53
	MCUCR = (1 << IVSEL);
    77de:	82 e0       	ldi	r24, 0x02	; 2
    77e0:	85 bf       	out	0x35, r24	; 53
	LED_SETUP();
    77e2:	3f 9a       	sbi	0x07, 7	; 7
    77e4:	20 9a       	sbi	0x04, 0	; 4
    77e6:	55 9a       	sbi	0x0a, 5	; 10
    77e8:	3e 9a       	sbi	0x07, 6	; 7
    77ea:	57 9a       	sbi	0x0a, 7	; 10
    TX_LED_OFF();
    77ec:	5d 9a       	sbi	0x0b, 5	; 11
	Init();
    77ee:	28 9a       	sbi	0x05, 0	; 5
  uint8_t _update = FLASH_readByte(0x00);
    77f0:	0e df       	rcall	.-484    	; 0x760e <Init>
    77f2:	60 e0       	ldi	r22, 0x00	; 0
    77f4:	70 e0       	ldi	r23, 0x00	; 0
    77f6:	cb 01       	movw	r24, r22
		  boot_rww_enable();
    77f8:	d6 dc       	rcall	.-1620   	; 0x71a6 <FLASH_readByte>
  if(_update == UPDATE){
    77fa:	c1 e1       	ldi	r28, 0x11	; 17
    77fc:	84 34       	cpi	r24, 0x44	; 68
	SPI_DISABLE;
    77fe:	61 f0       	breq	.+24     	; 0x7818 <main+0x42>
    7800:	8c b5       	in	r24, 0x2c	; 44
	StartSketch();
    7802:	8f 7b       	andi	r24, 0xBF	; 191
    7804:	8c bd       	out	0x2c, r24	; 44
}
    7806:	f5 de       	rcall	.-534    	; 0x75f2 <StartSketch>
    7808:	90 e0       	ldi	r25, 0x00	; 0
    780a:	80 e0       	ldi	r24, 0x00	; 0
      SPI_FlashImage();
    780c:	cf 91       	pop	r28
    780e:	08 95       	ret
		  boot_rww_enable();
    7810:	81 df       	rcall	.-254    	; 0x7714 <SPI_FlashImage>
    7812:	c0 93 57 00 	sts	0x0057, r28	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
	 while(RunBootloader){
    7816:	e8 95       	spm
    7818:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <RunBootloader>
    781c:	81 11       	cpse	r24, r1
    781e:	f8 cf       	rjmp	.-16     	; 0x7810 <main+0x3a>
    7820:	ef cf       	rjmp	.-34     	; 0x7800 <main+0x2a>

00007822 <_exit>:
    7822:	f8 94       	cli

00007824 <__stop_program>:
    7824:	ff cf       	rjmp	.-2      	; 0x7824 <__stop_program>
